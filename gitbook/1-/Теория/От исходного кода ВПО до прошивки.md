---
занятие:
  - "[[Как начать работать с микроконтроллерами]]"
дата: 2026-01-25
tags:
  - занятие1
  - теория
---
Теперь, когда мы знаем, что такое ВПО, разберемся с тем, как его собрать. В этом занятии весь код максимально упрощён, поэтому мы не будем касаться темы разработки самого проекта, а рассмотрим всё на примере базового проекта для любого микроконтроллера —**Мигающий светодиод** (*англ. blink*). Будем считать, что весь код для проекта у нас уже есть, и проследим процесс преобразования этого кода в файл-образ ВПО.
## Компиляция

У нас есть исходный код ВПО на языке Си (файлы `.c` и `.h`). Для микроконтроллера этот язык считается высокоуровневым, и он не может исполнить код на этом языке. Поэтому сначала нам необходимо перевести на более низкоуровневый язык, понятный для процессорного ядра микроконтроллера.

> [!NOTE] Определение
> **Компилятор** (*англ. compiler*) — программа, переводящая программу на языке высокого уровня в программу на языке более низкого уровня для конкретной аппаратной платформы

Когда вы компилируете программу на ПК при помощи компилятора под процессор ПК, первый создаёт код для того же самого процессора. Программа компилируется и запускается на одной и той же платформе.

Когда вы создаёте прошивку для микроконтроллера, ситуация другая:
- **Компиляция** происходит на вашем ПК (процессор x86 или ARM)
- **Выполнение** будет на микроконтроллере (процессор ARM Cortex-M)
Поэтому нужен специальный **кросс-компилятор**. Для ARM микроконтроллеров обычно используется `arm-none-eabi-gcc`.

> [!NOTE] Определение
> **Кросс-компиляция** (*англ. cross-compilation*) — компиляция исходного кода на одной аппаратной платформе для выполнения на другой.

Таким образом, у нас получится новый файл, в котором инструкции на Си будут преобразованы в инструкции ядра процессора (в нашем случае инструкции ядра Cortex-M0+). Выходной файл будет называться объектным.

## Компоновка

Объектный файл — это лишь часть прошивки: машинный код и данные для конкретной архитектуры, но адреса размещения в памяти микроконтроллера ещё не зафиксированы. Как мы помним из прошлых разделов, у микроконтроллера жёстко задана карта памяти, поэтому следующий шаг — скомпоновать все модули и библиотеки в единый образ: разложить код и данные по адресам Flash и RAM, разместить константы в нужных областях и связать обращения к функциям и переменным из библиотек.

> [!NOTE] Определение 
> **Линкер (компоновщик)** (*англ. linker*) — программа, которая объединяет объектные модули и библиотеки, разрешает внешние ссылки (символы), выполняет релокацию и формирует итоговый образ, размещая код и данные по адресам целевой памяти

Линкер берёт один или несколько объектных файлов и библиотеки, связывает их вместе и формирует выходной файл прошивки, в котором код и данные уже размещены по адресам Flash и RAM.

Для разметки памяти файла-образа прошивки используется **linker script** (скрипт компоновщика) — это конфигурационный файл, который задаёт как именно линкер должен сформировать итоговый образ: по каким адресам разместить секции программы (.text, .rodata, .data, .bss), какие области памяти считать Flash и RAM, и какие символы/границы (например, начало стека, границы куча/стек) определить.

В итоге у нас получается файл-образа ВПО, обычно прежде всего в формате .bin, но по необходимость его можно сконвертировать в другие форматы. Например, для RP2040 часто используют формат UF2: благодаря загрузчику, зашитому в ROM, плату можно перевести в режим USB‑накопителя и “прошить” устройство простым копированием файла, как на флешку.

## Набор инструментов

В итоге, путь от исходного кода ВПО до прошивки выглядит так:

```
main.c (исходный код на Си)
    │
    │  Компилятор
    │  (arm-none-eabi-gcc)
    ↓
main.o (объектный файл)
    │
    │  Линкер
    │  (ld)
    ↓
firmware.bin (исполняемый файл)
    │
    │  objcopy
    │  (конвертация формата)
    ↓
firmware.uf2 (файл для прошивки)
    │
    │  Копирование на Pico
    ↓
Flash платы Pico (внешняя для RP2040)
```

Набор программ, которые необходимы для прохождения этого пути, называется toolchain

>[!NOTE] Определение
> Набор инструментов (англ. toolchain) — это совокупность программ работающих последовательно для создания исполняемых файлов из исходного кода

Наш toolchain выглядит так:
- **Компилятор** (`arm-none-eabi-gcc`) — переводит `.c` в `.o`
- **Ассемблер** (`arm-none-eabi-as`) — обрабатывает низкоуровневый код
- **Линкер** (`arm-none-eabi-ld`) — собирает всё в один файл
- **Утилиты** (`objcopy`, `objdump`, `size`) — работа с файлами

| **[[Встроенное программное обеспечение\|Предыдущий раздел]]** | [[Как начать работать с микроконтроллерами\|К занятию]] | **[[SDK — готовые программные компоненты\|Следующий раздел]]** |
| ------------------------------------------------------------------------ | ------------------------------------------------------- | -------------------------------------------------------------- |
