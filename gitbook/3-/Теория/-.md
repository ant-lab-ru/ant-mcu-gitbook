---
занятие:
  - "[[Как работать с периферией микроконтроллера]]"
дата: 2026-02-18
tags:
  - занятие3
  - теория
---

В статье [[Разбираемся с периферией на примере АЦП]] мы увидели, что у каждого регистра есть битовые поля: один бит включает питание, три бита выбирают канал и т.д. Регистр один — 32 бита, а менять нужно только часть из них. Как в коде записать или прочитать отдельное поле, не затронув остальные биты? Ниже — основные приёмы и то, как они выглядят в Pico SDK.

## Зачем нужны отдельные операции с полями

Регистр в памяти — это одно 32-битное слово. Если мы просто запишем в него новое значение командой вида `*addr = 0x00000001`, мы обнулим все остальные биты. Например, в регистре CS АЦП в бите 0 — EN, в битах 14:12 — AINSEL. Запись «включить АЦП» как `*addr = 1` обнулит выбор канала и все прочие поля. Нужны операции, которые меняют только выбранные биты и оставляют остальные без изменений.

>[!NOTE] Определение
>**Битовое поле** (*bit field*) — группа из одного или нескольких подряд идущих битов в регистре, имеющая отдельное назначение (например, «включение питания», «номер канала»). В коде с полем работают через **маску** (какие биты относятся к полю) и, при необходимости, **сдвиг** (на какую позицию сдвинуто значение поля в регистре).

## Чтение поля: маска и сдвиг

Чтобы прочитать поле, нужно «вырезать» из регистра нужные биты и получить их в младших разрядах числа. Два шага: поразрядное И с маской (оставить только биты поля), затем сдвиг вправо до младшего бита.

Пример: поле **AINSEL** в регистре CS АЦП занимает биты 14:12; маска `0x00007000` (единицы только в позициях 12–14). Пусть в регистре установлены: EN (0), TS_EN (1), START_MANY (3), READY (8), AINSEL = 5 в битах 14:12, в RROBIN (20:16) — единицы в битах 16 и 20. В таблице — полные 32 бита и шестнадцатеричное значение.

| Операция                        | Битовое представление (32 бита)           | Hex        |
| ------------------------------- | ----------------------------------------- | ---------- |
| Исходный регистр                | `0000 0000 0001 0010 0101 0000 0001 1011` | 0x0012501B |
| Маска (поле AINSEL, биты 14:12) | `0000 0000 0000 0000 0111 0000 0000 0000` | 0x00007000 |
| Регистр AND маска               | `0000 0000 0000 0000 0101 0000 0000 0000` | 0x00005000 |
| Сдвиг вправо на 12              | `0000 0000 0000 0000 0000 0000 0000 0101` | 0x00000005 |

В первой строке — полное содержимое регистра: в младших битах видны EN, TS_EN, START_MANY, READY, в битах 14:12 — значение канала `101` (5), в битах 20:16 — флаги RROBIN. Во второй строке — сама маска: единицы только в позициях 12–14. В третьей строке после AND остаются только биты поля AINSEL, остальные обнулены. В четвёртой строке сдвиг вправо на 12 переносит значение поля в младшие биты — получаем число 5 (0x05).

В коде то же самое:

```c
uint32_t cs = *((volatile uint32_t *)ADC_CS_ADDR);
uint32_t ainsel = (cs & 0x00007000u) >> 12;
```

В SDK маска и сдвиг заданы константами (`ADC_CS_AINSEL_BITS`, `ADC_CS_AINSEL_LSB`), и чтение поля часто обёрнуто в функцию.

## Запись поля: не затереть остальное

Запись в поле сложнее: нужно изменить только его биты, не трогая остальные. Общая схема:

1. Прочитать текущее значение регистра.
2. Обнулить в нём биты поля (применить инвертированную маску: `reg & ~mask`).
3. Подготовить новое значение поля и сдвинуть его на позицию поля в регистре.
4. Объединить результат поразрядным ИЛИ с прочитанным и обнулённым значением.
5. Записать результат обратно по адресу регистра.

Для однобитового поля «установить в 1» достаточно шагов 1, 4 (новое значение = маска), 5 — это по сути «прочитать, ИЛИ с маской, записать». Для «установить в 0» — «прочитать, И с инверсией маски, записать».

### Установка битов (set)

Включить один или несколько битов, не трогая остальные:

```c
*((volatile uint32_t *)ADC_CS_ADDR) |= ADC_CS_EN_BITS;
```

Операция ИЛИ с маской оставляет единицы в нужных битах; остальные биты регистра не меняются.

### Сброс битов (clear)

Выключить один или несколько битов:

```c
*((volatile uint32_t *)ADC_CS_ADDR) &= ~ADC_CS_EN_BITS;
```

Инверсия маски даёт единицы везде, кроме поля; операция И с регистром обнуляет только эти биты.

### Запись произвольного значения в поле (write masked)

Когда в поле нужно записать не «все единицы» и не «все нули», а число из нескольких бит (например, номер канала 0–4 в AINSEL), делают два шага: обнуляют поле по маске, затем поразрядное ИЛИ со сдвинутым значением. Пример: в регистре CS сейчас выбран канал 5 (AINSEL = `101`), нужно переключить на канал 3 (AINSEL = `011`). Маска поля по‑прежнему `0x00007000`.

| Операция | Битовое представление (32 бита) | Hex |
|----------|----------------------------------|-----|
| Исходный регистр | `0000 0000 0001 0010 0101 0000 0001 1011` | 0x0012501B |
| Маска поля AINSEL | `0000 0000 0000 0000 0111 0000 0000 0000` | 0x00007000 |
| Регистр после обнуления поля (reg AND NOT маска) | `0000 0000 0001 0010 0000 0000 0001 1011` | 0x0012001B |
| Новое значение (3), сдвиг влево на 12 | `0000 0000 0000 0000 0011 0000 0000 0000` | 0x00003000 |
| Итоговый регистр (обнулённый OR новое значение) | `0000 0000 0001 0010 0011 0000 0001 1011` | 0x0012301B |

В первой строке — регистр до записи (в битах 14:12 по-прежнему 5). Во второй — маска поля. В третьей биты 14:12 обнулены, остальные не тронуты. В четвёртой — значение 3, сдвинутое в позицию поля. В пятой — результат ИЛИ: в поле AINSEL теперь 3, остальные биты как в третьей строке.

В коде то же самое:

```c
uint32_t reg = *((volatile uint32_t *)ADC_CS_ADDR);
reg &= ~ADC_CS_AINSEL_BITS;
reg |= (input << ADC_CS_AINSEL_LSB) & ADC_CS_AINSEL_BITS;
*((volatile uint32_t *)ADC_CS_ADDR) = reg;
```

## Атомарность и прерывания

Если между чтением и записью регистра может сработать прерывание и изменить тот же регистр, «прочитал — изменил — записал» может затереть чужое изменение. В таких случаях в SDK и в железе часто предусмотрены атомарные операции: одна инструкция «установить биты по маске» или «очистить биты по маске», без промежуточного чтения в переменную. Подробнее об этом говорят в курсе при разборе прерываний и многозадачности.

## Как это сделано в Pico SDK

В Pico SDK адреса регистров и маски полей объявлены в заголовках из папки `regs`; для работы с регистрами используются обёртки вроде `hw_set_bits()`, `hw_clear_bits()`, `hw_write_masked()`. Они принимают указатель на регистр и маску (или маску и значение) и выполняют нужную последовательность операций, в том числе с учётом атомарности там, где это нужно. В статье [[Разбираемся с периферией на примере АЦП#От регистров к SDK]] показаны примеры: `adc_set_temp_sensor_enabled()` внутри вызывает `hw_set_bits` / `hw_clear_bits`, а `adc_select_input()` — `hw_write_masked()`. Понимая, как устроены set/clear/write masked, вы можете при необходимости написать доступ к новому полю по даташиту без готовой функции SDK.

## Краткая сводка

| Задача | Идея | В C (псевдокод) |
|--------|------|-----------------|
| Прочитать поле | Регистр AND маска, сдвиг вправо | `(reg & MASK) >> LSB` |
| Установить биты в 1 | Регистр OR маска | `reg \|= MASK` |
| Сбросить биты в 0 | Регистр AND (NOT маска) | `reg &= ~MASK` |
| Записать значение в поле | Обнулить поле, затем OR (значение << LSB) | `reg = (reg & ~MASK) \| ((val << LSB) & MASK)` |

В реальном коде вместо «сырых» маски и сдвига используют константы из даташита или из SDK (`*_BITS`, `*_LSB`), а сами операции часто скрыты в функциях типа `hw_set_bits()` и `hw_write_masked()`.

| **[[Разбираемся с периферией на примере АЦП\|Предыдущий раздел]]** | [[Как работать с периферией микроконтроллера\|К занятию]] | **[[Сбор данных с микроконтроллера в Python\|Следующий раздел]]** |
| ---- | ---- | ---- |
