---
занятие:
  - "[[Как работать с периферией микроконтроллера]]"
дата: 2026-02-18
tags:
  - занятие3
  - теория
---

Мы уже знаем, что такое [[Периферия микроконтроллера|внутренняя периферия]] и как ею управлять через [[Регистры периферии|регистры по шине памяти]]. Теперь применим эти знания к конкретному модулю — **АЦП** (*Analog-to-Digital Converter*, аналого-цифровой преобразователь). На его примере вы увидите, как карта регистров превращается в настройки и данные, как устроена схема работы периферии и что делают за вас функции SDK.

>[!ATTENTION] Внимание!
>В этом разделе мы будем читать даташит RP2040 — настоятельно рекомендуем открыть его и читать вместе с этой статьёй.

## Основная информация

Сначала вспомним, что такое АЦП, затем найдём его в даташите. 

>[!NOTE] Определение
>**АЦП** (*Analog-to-Digital Converter*, аналого-цифровой преобразователь) — модуль, преобразующий аналоговое напряжение на входе в цифровой код фиксированной разрядности.

С базовой идеей АЦП вы уже знакомы по курсу физики и по работе с внешним АЦП на Raspberry Pi. В микроконтроллере АЦП нужен, чтобы измерять напряжение на выбранных выводах (потенциометр, датчик с аналоговым выходом) или встроенный источник (например, внутренний датчик температуры).

Для знакомства с данным модулем периферии найдём его в [[RP2040 Datasheet.pdf#page=559|даташите, пункт 4.9]]. 

Сначала мы встречаем общее описание характеристик АЦП:
- **SAR ADC** — это АЦП последовательного приближения с бинарным поиском (такое мы делали с вами на парах по общеинженерной подготовке);
- в следующей строчке указана частота дискретизации **500 квыб/с**;
- далее указана разрядность **12 бит**;
- у АЦП есть мультиплексор, который позволяет подключать его к пяти разным физическим источникам сигнала: к четырём пинам `GPIO[26-29]` и встроенному температурному сенсору;
- у модуля есть встроенный блок памяти **FIFO** на восемь элементов;
- модуль может генерировать **прерывания** и может быть подключён к **DMA**.

Ниже идёт схема подключения АЦП к разным ножкам. В целом после прочтения этой информации мы можем понять, на какие инструменты можем рассчитывать при использовании этого модуля и ещё до начала разработки определить, подойдёт ли такой АЦП для наших задач или нет. Если нет — в нашем устройстве придётся предусмотреть подключение внешнего АЦП.

Далее в даташите идёт раскрытие внутреннего устройства модуля; мы же пока перейдём к концу описания АЦП и найдём карту регистров.

## Карта регистров АЦП

[[RP2040 Datasheet.pdf#page=565|Откроем пункт 4.9.6 List of Registers]]. Мы сразу увидим, что базовый адрес модуля АЦП на системной шине памяти — `0x4004c000`; значит, все последующие адреса в этом разделе даташита указывают лишь смещение относительно этого адреса, а не абсолютный адрес регистра. Значение базового адреса определено в SDK в константе `ADC_BASE`. Это важная характеристика любого периферийного модуля, поэтому базовый адрес задан в SDK для всех периферийных модулей.

Ниже в даташите представлена таблица всех регистров модуля АЦП. Как видите, их всего девять. Адреса указаны в виде смещения от базового в шестнадцатеричном формате с шагом 4 — так как шина памяти 32-битная, одно слово занимает 4 байта.

>[!ATTENTION] Внимание!
>В микроконтроллерах адреса чаще всего указываются в байтах, но обращение по шине памяти возможно только к словам. Поэтому хотя, например, байт с адресом `0x03` физически существует, доступ к нему мы можем получить только считав слово по адресу `0x00` и взяв из него нужный байт.

Давайте посмотрим, какие регистры есть у нашего АЦП. 

### Регистр CS и битовые поля

По смещению `0x00` идёт регистр **CS** (сокращение от *Control and Status*). Каждый регистр представлен в виде битовых полей; сразу после общей таблицы в даташите идёт таблица с описанием полей этого регистра. Зачем так? Расточительно отводить все 32 бита на один параметр: например, для одного сигнала «включить модуль АЦП» достаточно одного бита. Поэтому 32 бита делят на поля произвольной длины.

У каждого поля в таблице обычно указаны:
- смещение относительно младшего бита регистра;
- ширина в битах;
- тип доступа к полю;
- значение после сброса.

Остальные параметры понятны; о третьем поговорим отдельно. Типы доступа к битовому полю:
- **RO** (*Read-Only*, только чтение): при чтении по шине модуль вернёт текущее значение поля; при записи значение этого бита в транзакции игнорируется;
- **RW** (*Read-Write*, чтение и запись): при записи значение поля сохраняется в модуле, при чтении получаем текущее значение;
- **WC** (*Write-Clear*, сброс при записи): при чтении получаем значение поля; при записи единицы в это поле оно сбрасывается в 0;
- **SC** (*Self-Clear*, самоочищающийся): при записи мы выставляем значение (например, 1), через один такт оно автоматически сбрасывается в 0. Так обычно передают команды модулю («запустить одно измерение»).

Некоторые поля в таблице помечены как *Reserved*. Это значит, что транзакции по шине на них не должны влиять; они зарезервированы для будущих версий.

Теперь, когда мы поняли, как читать таблицу полей регистра `CS`, рассмотрим, какие поля в нём есть. В даташите таблица начинается со старших бит; мы пойдём с младших:

- **0:0** — **EN** — **RW**: включение питания АЦП (0 — выключено, 1 — включено). Поле доступно и для чтения, и для записи — так можно достоверно узнать, включён ли АЦП. После сброса значение 0.
- **1:1** — **TS_EN** — **RW**: включение питания температурного сенсора (0 — выключено, 1 — включено). Логика та же, что и для EN.
- **2:2** — **START_ONCE** — **SC**: запуск одного измерения. При записи 1 в этот бит АЦП выполняет одно преобразование; бит затем автоматически сбрасывается.
- **3:3** — **START_MANY** — **RW**: непрерывные измерения (1 — запуск, 0 — остановка). При записи 1 модуль непрерывно выполняет измерения; чтобы остановить — записать 0.
- **7:4** — зарезервированы.
- **8:8** — **READY** — **RO**: готовность к новому измерению (0 — идёт измерение, 1 — измерение завершено, можно запускать следующее).
- **9:9** — **ERR** — **RO**: ошибка текущего измерения (1 — АЦП не смог оцифровать сигнал).
- **10:10** — **ERR_STICKY** — **WC**: «липкий» флаг ошибки — остаётся 1 после первой ошибки. Очищается записью 1 в это поле.
- **11:11** — зарезервирован.
- **14:12** — **AINSEL** — **RW**: выбор аналогового канала (0–4). Каналов пять, поэтому поле шириной 3 бита (2³ = 8 ≥ 5). Значение в этом поле может автоматически меняться алгоритмом Round-Robin (об этом позже).
- **15** — зарезервирован.
- **20:16** — **RROBIN** — **RW**: включение Round-Robin по каналам. Пять бит — по одному на канал; установленный бит подключает соответствующий канал к циклическому перебору.

>[!NOTE] Определение
>**Алгоритм Round-Robin** — циклический перебор элементов из заданного набора.

Так выглядит описание регистра управления и статуса. Возникает вопрос: когда мы в коде записываем единицу в бит `EN` или `START_ONCE`, что на самом деле происходит в микросхеме? Запись по адресу регистра — это транзакция на шине памяти: процессор отправляет адрес и значение, а блок, «привязанный» к этому адресу, их принимает. Внутри блока АЦП принятое значение попадает в ячейки хранения — те самые битовые поля регистра. В схемотехнике такая ячейка хранит не число «в уме», а реальное напряжение на миниатюрном узле схемы: условно 0 В — логический ноль, около 3,3 В — логическая единица. К этим же узлам подключены входы остальной схемы АЦП: компараторы, ключи питания, автомат управления преобразованием. Они постоянно «смотрят» на уровни напряжения в регистре: увидели единицу в бите EN — подали питание на аналоговую часть; увидели единицу в START_ONCE — запустили один цикл преобразования. Таким образом, запись бита в программе в итоге меняет напряжение в конкретной точке кристалла, а уже это напряжение переключает реальные транзисторы и приводит к физическому действию — включению питания, выбору канала или старту измерения. Для программиста удобно представлять битовые поля как «внутренние GPIO»: те же нули и единицы, только не на выводах корпуса, а на соединениях между блоками внутри микросхемы.

Мы не разбираем здесь все регистры АЦП — это заняло бы слишком много места. Важно, что мы показали концепцию описания регистров периферии — она применима не только к RP2040, но и к другим микроконтроллерам: принципы работы с периферией везде одни и те же.

### Как происходит одно измерение

По полям регистра `CS` и регистру результата `RESULT` (в даташите — следующий после `CS`, из него читают 12-битный цифровой код) складывается цепочка одного измерения:

1. **Включить питание** — записать 1 в поле **EN** регистра CS. Если нужен температурный сенсор, дополнительно записать 1 в **TS_EN**.
2. **Выбрать канал** — записать в **AINSEL** номер канала (0–4): внешний пин или температурный сенсор.
3. **Запустить преобразование** — записать 1 в **START_ONCE** (бит сам сбросится).
4. **Дождаться готовности** — опрашивать поле **READY**: пока там 0, идёт преобразование; при 1 можно читать результат.
5. **Прочитать результат** — считать значение из регистра результата АЦП (смещение и имя смотрите в карте регистров в даташите). Получим 12-битный код 0–4095.

Пока **READY** не равен 1, результат предыдущего измерения может быть ещё не обновлён или невалиден. При непрерывном режиме (**START_MANY** = 1) шаги 3–5 повторяются аппаратно.
## От регистров к SDK

Вся работа с периферией в коде сводится к записи и чтению битов в нужных полях регистров. При этом регистр — одно 32-битное слово, а менять нужно только отдельные биты (например, EN или AINSEL), не затронув остальные. Как это делают в коде — чтение поля по маске и сдвигу, установка и сброс битов, запись значения в многобитное поле — разобрано в отдельной заметке: [[Чтение и запись битовых полей в регистрах]]. Теоретически можно по даташиту описать все поля всех регистров вручную, но это трудоёмко, а периферийных модулей десятки. Поэтому микроконтроллер поставляется с SDK, в котором эти описания и обёртки уже сделаны за нас.

>[!INFO] Дополнительно
>Некоторые разработчики ВПО считают штатный SDK производителя неудобным или недостаточно эффективным и пишут поверх него свой слой или свой SDK на базе имеющегося.

Давайте посмотрим, где в SDK заданы регистры и поля АЦП. Адреса и маски битов должны быть где-то объявлены в коде. В Pico SDK за это отвечает папка `regs`; [в ней описаны регистры всех периферий](https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2040/hardware_regs/include/hardware/regs/). Откройте файл `adc.h`. Вот как там описан регистр `CS`:
```c
// Register    : ADC_CS
// Description : ADC Control and Status
#define ADC_CS_OFFSET _u(0x00000000)
#define ADC_CS_BITS   _u(0x001f770f)
#define ADC_CS_RESET  _u(0x00000000)
```

Константа `ADC_CS_BITS` задаёт битовую маску регистра — то есть все биты, которые не помечены как *Reserved*.

Вот как в том же файле описано поле `CS_EN`:

```c
// Field       : ADC_CS_EN
// Description : Power on ADC and enable its clock.
//               1 - enabled. 0 - disabled.
#define ADC_CS_EN_RESET  _u(0x0)
#define ADC_CS_EN_BITS   _u(0x00000001)
#define ADC_CS_EN_MSB    _u(0)
#define ADC_CS_EN_LSB    _u(0)
#define ADC_CS_EN_ACCESS "RW"
```

И поле `CS_TS_EN`:

```c
// Field       : ADC_CS_TS_EN
// Description : Power on temperature sensor. 1 - enabled. 0 - disabled.
#define ADC_CS_TS_EN_RESET  _u(0x0)
#define ADC_CS_TS_EN_BITS   _u(0x00000002)
#define ADC_CS_TS_EN_MSB    _u(1)
#define ADC_CS_TS_EN_LSB    _u(1)
#define ADC_CS_TS_EN_ACCESS "RW"
```

Выше в SDK объявлены функции, которые работают с этими регистрами. Например, включение температурного сенсора:
```c
static inline void adc_set_temp_sensor_enabled(bool enable) {
    if (enable)
        hw_set_bits(&adc_hw->cs, ADC_CS_TS_EN_BITS);
    else
        hw_clear_bits(&adc_hw->cs, ADC_CS_TS_EN_BITS);
}
```

Если `enable == true`, функция выставляет в регистре `CS` биты поля `TS_EN` (*SET* — установить в 1); иначе очищает эти биты (*CLEAR* — установить в 0).

Функция выбора канала АЦП:

```c
static inline void adc_select_input(uint input) {
    valid_params_if(HARDWARE_ADC, input < NUM_ADC_CHANNELS);
    hw_write_masked(&adc_hw->cs, input << ADC_CS_AINSEL_LSB, ADC_CS_AINSEL_BITS);
}
```

Сначала проверяется, что `input` меньше числа каналов; затем в регистр `CS` в биты поля `AINSEL` записывается значение `input`.

Зачем это показывать? Чтобы было ясно: в SDK нет «магии». Там те же операции, что и при ручной работе с регистрами — запись и чтение битов по адресам. Они обёрнуты в проверки параметров и удобные имена, но суть одна: обращение к памяти по адресам из карты регистров.

## Итог

На примере АЦП мы применили общие понятия — внутренняя периферия, карта регистров, обращение по шине памяти — к конкретному модулю. Вы увидели, как в даташите описываются регистры и битовые поля, как по ним включается питание, выбирается канал и запускается преобразование, и как те же действия реализованы в Pico SDK через константы и функции. В заданиях вы будете вызывать эти функции (например, для `get_adc()` и `get_temp()`), уже понимая, что за ними стоит.

| **[[Регистры периферии\|Предыдущий раздел]]** | [[Как работать с периферией микроконтроллера\|К занятию]] | **[[Сбор данных с микроконтроллера в Python\|Следующий раздел]]** |
| --------------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |
