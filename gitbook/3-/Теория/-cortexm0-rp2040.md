---
занятие:
  - "[[Как работать с периферией микроконтроллера]]"
дата: 2026-02-17
tags:
  - занятие3
  - теория
---

В статье [[Регистры периферии]] мы разобрали, что такое регистр вообще и как устроен доступ к регистрам периферии по шине памяти. Отдельно были упомянуты **регистры процессора** — они принадлежат самому ядру и отличаются от регистров периферии и способом доступа, и назначением. Зачем разработчику ВПО их знать? При отладке отладчик неизбежно показывает значения этих регистров: адрес остановки, содержимое стека, флаги. Без понимания, что за что отвечает, вы не сможете осознанно искать причину сбоя. Давайте разберёмся, что такое регистры ядра с точки зрения программиста и куда смотреть, когда программа ведёт себя не так.

## Регистры ядра с точки зрения разработчика ВПО

>[!NOTE] Определение
>**Регистры ядра** (*core registers*) — набор регистров внутри процессорного ядра, в которых хранятся текущие данные и состояние выполняемой программы. Команды процессора работают с этими регистрами напрямую (читают операнды, записывают результат); к ним же обращается отладчик при остановке программы.

Не нужно представлять себе цифровые схемы и триггеры. Для разработчика встроенного ПО регистры ядра — это **рабочая память процессора**: небольшой набор именованных ячеек фиксированного размера (в Cortex-M0+ — 32 бита каждая), в которых лежат аргументы и результаты операций, адрес следующей команды, адрес вершины стека и служебная информация. Компилятор и соглашения вызовов (*calling conventions*) решают, в каких регистрах передаются аргументы и возвращаемое значение; при отладке вы смотрите именно эти регистры, чтобы понять, на какой строке остановились, какие значения получила функция и не повреждён ли стек.

В RP2040 два ядра Cortex-M0+; у **каждого ядра свой независимый набор** регистров. Когда выполняется код на ядре 0, вы видите регистры ядра 0; при переключении на поток ядра 1 отладчик показывает уже регистры ядра 1.

## Назначение регистров Cortex-M0+

Ядро ARM Cortex-M0+ имеет небольшой и фиксированный набор регистров. Их можно разделить на регистры общего назначения и служебные.

### Регистры общего назначения R0–R12

В **R0–R12** хранятся произвольные 32-битные значения: переменные, аргументы функций, промежуточные результаты. С точки зрения программы они взаимозаменяемы «по смыслу», но соглашение вызовов ARM закрепляет за частью из них строгие роли:

- **R0–R3** — аргументы при вызове функции и возвращаемое значение (R0). Если аргументов больше четырёх, остальные передаются через стек. При отладке в R0 часто лежит результат только что вызванной функции или первый аргумент текущей.
- **R4–R11** — регистры, которые **должен сохранять вызываемый код** (*callee-saved*): если функция их использует, она обязана перед возвратом восстановить прежние значения. В них компилятор хранит локальные переменные, которые должны пережить вызовы других функций. При отладке по ним можно судить о «местных» данных функции.

Таким образом, при остановке на строке кода в R0–R3 чаще всего видны аргументы и возвращаемое значение, в R4–R11 — сохранённые локальные данные.

### Указатель стека SP (R13)

**R13** используется процессором как **указатель стека** (*Stack Pointer*, SP). В нём хранится адрес вершины стека: по этому адресу процессор кладёт новые значения при вызове функций и при выделении места под локальные переменные и забирает при возврате. В Cortex-M есть два стека: основной **MSP** (*Main Stack Pointer*) и стек процессов **PSP** (*Process Stack Pointer*); в типичной прошивке на Pico используется один стек (MSP). При отладке важно убедиться, что SP указывает на валидную область RAM: если значение SP «дикое» (например, ноль или адрес за пределами памяти), следующий вызов или возврат почти наверняка приведёт к сбою.

### Регистр связей LR (R14)

**R14** называется **Link Register** (LR): в него аппаратно записывается адрес возврата при вызове подпрограммы по команде `BL`. При возврате из функции команда `BX LR` передаёт управление по этому адресу. В отладчике по LR можно понять, **откуда была вызвана** текущая функция: если остановились внутри `gpio_put()`, то в LR будет адрес в вашем коде, откуда вызвали `gpio_put()`. Это особенно полезно при падении внутри библиотеки — вы сразу видите место вызова в своей программе.

### Счётчик команд PC (R15)

**R15** — **Program Counter** (PC): адрес **следующей** выполняемой инструкции. Когда отладчик останавливает программу, он показывает текущую точку останова; отображаемый PC обычно указывает на эту команду (или на следующую, в зависимости от отладчика). При сбое (например, переход по неверному адресу или аппаратное исключение) первое, на что смотрят — **PC**: по нему видно, в каком коде произошла остановка. Если PC указывает «в пустоту» или на неверный адрес, причина часто в повреждённом указателе или возвратном адресе на стеке.

### Регистр состояния программы PSR

**PSR** (*Program Status Register*) — составной регистр, в котором хранятся **флаги результатов** последних операций и состояние выполнения:

- **N** (*Negative*) — результат отрицательный (установлен старший бит).
- **Z** (*Zero*) — результат ноль (часто им пользуются условные переходы: «если Z=1, перейти»).
- **C** (*Carry*) — перенос или заём при арифметике.
- **V** (*oVerflow*) — переполнение при знаковой арифметике.

По ним процессор решает, выполнять ли условный переход (например, «перейти, если равно»). При отладке флаги помогают понять, почему выполнение пошло по одной ветке, а не по другой. В PSR также хранится номер активного прерывания (если выполняется обработчик) и другие служебные биты — их можно не трогать на первом этапе, но знать об их существовании полезно.

### PRIMASK и CONTROL

- **PRIMASK** — один бит: при значении 1 все маскируемые прерывания глобально запрещены. Иногда в коде временно отключают прерывания; если забыть снова включить, система может «зависнуть» или не реагировать на события. В отладчике можно проверить, не остался ли PRIMASK установленным.
- **CONTROL** — выбор стека (MSP/PSP) и уровень привилегий. В простых прошивках на Pico его редко меняют; при отладке многозадачных или защищённых систем по нему смотрят, какой стек и какой режим используются.

## Куда смотреть при отладке

Сводка для быстрого использования в отладчике (например, в VS Code при остановке на breakpoint или при просмотре дампа после сбоя):

| Что проверить | Зачем |
| --------------| ----- |
| **PC** | Где остановилась программа или где произошло исключение. Если адрес «странный» — возможны повреждение стека или неверный переход. |
| **SP** | Указатель стека должен быть в пределах области RAM (например, для Pico — в диапазоне выделенного стека). Иначе следующие вызовы/возвраты приведут к падению. |
| **LR** | Из какой функции/файла вызвана текущая. Удобно при падении внутри библиотеки: смотрите LR и переходите к месту вызова в своём коде. |
| **R0** | Часто — возвращаемое значение последней функции или первый аргумент текущей. По R0–R3 можно проверить аргументы вызова. |
| **PSR (N, Z, C, V)** | Почему сработал условный переход; при отладке циклов и условий — почему ветвление пошло не туда. |
| **PRIMASK** | Если 1 — прерывания отключены; при «зависаниях» и нереагировании на события стоит проверить. |

Таким образом, регистры ядра для разработчика ВПО — это не абстракция схемотехники, а **конкретные места, где лежит состояние программы**. Понимая назначение PC, SP, LR и R0–R3, вы сможете осознанно пользоваться отладчиком и быстрее находить причину сбоев.

## Сводная таблица регистров ядра Cortex-M0+

| Регистр | Название                          | Назначение                                                                    |
| ------- | --------------------------------- | ----------------------------------------------------------------------------- |
| R0      | —                                 | Общего назначения (аргументы, результат, временные данные)                    |
| R1      | —                                 | Общего назначения                                                             |
| R2      | —                                 | Общего назначения                                                             |
| R3      | —                                 | Общего назначения                                                             |
| R4–R7   | —                                 | Общего назначения (вызываемый код должен сохранять при вызове)                |
| R8–R12  | —                                 | Общего назначения (вызываемый код должен сохранять при вызове)                |
| R13     | **SP** (Stack Pointer)            | Указатель стека: адрес вершины стека (MSP или PSP)                            |
| R14     | **LR** (Link Register)            | Адрес возврата из подпрограммы                                                |
| R15     | **PC** (Program Counter)          | Адрес следующей выполняемой инструкции                                        |
| —       | **PSR** (Program Status Register) | Флаги (N, Z, C, V), номер активного прерывания, состояние выполнения          |
| —       | **PRIMASK**                       | Один бит: блокировка всех маскируемых прерываний (1 = заблокированы)          |
| —       | **CONTROL**                       | Выбор указателя стека (MSP/PSP), уровень привилегий (privileged/unprivileged)  |

>[!NOTE] Попробуйте
>Поставьте точку останова в своей программе на Pico и откройте панель регистров в отладчике (в VS Code — раздел «Variables» или «Registers», если включён). Посмотрите значения PC, SP, LR и R0 при входе в функцию и при возврате — так вы наглядно увидите, как они соответствуют месту в коде и соглашению вызовов.

