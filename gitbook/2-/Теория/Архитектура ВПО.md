---
занятие:
  - "[[Как начать писать код для микроконтроллера]]"
дата: 2026-02-11
tags:
  - занятие2
  - теория
---

В [[От ВПО к Устройству|прошлом разделе]] мы пришли к важному выводу: как только у устройства появляется пользователь и интерфейс, линейное выполнение кода перестаёт работать. Пока программа стоит в `sleep_ms(250)`, она не реагирует ни на кнопки, ни на данные из терминала. На Raspberry Pi эту проблему решала операционная система — Linux сам переключал процессы и потоки. На микроконтроллере ОС нет, и организовывать поведение программы придётся нам самим.

В этом разделе мы разберём два ключевых инструмента для этого: **задачи** — способ разбить программу на независимые части, и **машину состояний** — способ организовать логику внутри каждой части.

## Задачи — из чего состоит программа

Представьте умный термостат. Ему нужно одновременно:
- читать температуру с датчика,
- обновлять дисплей,
- реагировать на нажатия кнопок,
- управлять нагревателем,
- отправлять данные по сети.

Каждое из этих действий — отдельная **задача**.

>[!NOTE] Определение
>**Задача** (*англ. task*) — независимая программная единица, которая выполняет одну конкретную функцию в системе. Задачи работают псевдопараллельно: на одном ядре процессора они выполняются по очереди, но достаточно быстро, чтобы казалось, что всё происходит одновременно.

Ключевые свойства хорошей задачи:
- **Самостоятельность** — у задачи своя логика работы
- **Одна ответственность** — каждая задача отвечает за одну функцию системы
- **Минимальная связность** — задачи как можно меньше зависят друг от друга

## Суперцикл — простейшая архитектура

Самый простой способ запустить несколько задач — вызывать их по очереди в бесконечном цикле:

```c
int main() {
    init_system();

    while (1) {
        task_button_check();   // Задача: опрос кнопок
        task_led_control();    // Задача: управление светодиодом
        task_sensor_read();    // Задача: чтение датчика
        task_uart_process();   // Задача: обработка UART
    }
}
```

Это и есть **суперцикл** (*англ. super loop*) — архитектура, которую вы уже использовали в blink. Один бесконечный `while(1)`, внутри которого вызываются все функции-задачи.

**Достоинства:**
- Проще некуда — понятно, что и когда выполняется
- Нет накладных расходов на переключение между задачами
- Предсказуемый порядок выполнения

**Проблема:** если одна задача «зависла» или вызвала `sleep_ms()`, все остальные стоят и ждут. Именно это мы наблюдали в blink — пока горит `sleep_ms(250)`, программа глуха ко всему остальному.

## Неблокирующий подход — используем время

В [[Время внутри микроконтроллера|разделе про время]] мы изучили `time_us_64()` и `get_absolute_time()`. Вместо того чтобы блокировать программу через `sleep_ms()`, можно **проверять**, прошло ли нужное время, и если нет — просто идти дальше:

```c
uint64_t last_blink_time = 0;

void task_blink(void) {
    uint64_t now = time_us_64();
    if (now - last_blink_time >= 250000) {  // 250 мс = 250000 мкс
        gpio_put(LED_PIN, !gpio_get(LED_PIN));
        last_blink_time = now;
    }
    // Если 250 мс ещё не прошли — сразу выходим, не блокируя
}
```

Теперь `task_blink()` не блокирует выполнение: если 250 мс ещё не прошли, функция мгновенно возвращается, и суперцикл переходит к следующей задаче. Светодиод мигает, но другие задачи тоже работают.

>[!NOTE] Из практики
>Паттерн «проверь время → если пора, выполни → обнови метку» — основа неблокирующего программирования на микроконтроллерах. Вы будете встречать его повсюду: в библиотеках, в примерах SDK, в промышленном коде.

## Кооперативная многозадачность

Идею «каждая задача проверяет своё время» можно оформить системно. Заведём таблицу задач с периодами и напишем **планировщик** (*англ. scheduler*), который сам решает, какую задачу пора запускать:

```c
typedef struct {
    void (*function)(void);   // Функция задачи
    uint32_t period_ms;       // Период запуска (мс)
    uint32_t last_run_ms;     // Время последнего запуска
} Task;

Task tasks[] = {
    {task_button_check,  10,   0},  // Кнопки — каждые 10 мс
    {task_led_control,   250,  0},  // Светодиод — каждые 250 мс
    {task_sensor_read,   1000, 0},  // Датчик — каждую секунду
    {task_uart_process,  5,    0},  // UART — каждые 5 мс
};

void scheduler(void) {
    uint32_t now = to_ms_since_boot(get_absolute_time());
    for (int i = 0; i < 4; i++) {
        if (now - tasks[i].last_run_ms >= tasks[i].period_ms) {
            tasks[i].function();            // выполняем задачу
            tasks[i].last_run_ms = now;     // обновляем метку времени
        }
    }
}

int main() {
    stdio_init_all();
    // ... инициализация периферии ...

    while (1) {
        scheduler();
    }
}
```

Это **кооперативная многозадачность** (*англ. cooperative multitasking*): задачи «договариваются» работать быстро и возвращать управление планировщику. Никто не блокирует выполнение — каждая задача запускается в своё время, а суперцикл крутится непрерывно.

>[!ATTENTION] Внимание!
>В кооперативной многозадачности критически важно, чтобы каждая задача выполнялась быстро. Если `task_sensor_read()` решит подождать ответа от датчика через `sleep_ms(100)`, вся система «встанет» на это время. Задачи должны быть неблокирующими — выполнил и вернул управление.

>[!INFO] Дополнительно
>В профессиональной разработке для сложных систем используют **RTOS** (*Real-Time Operating System*) — операционную систему реального времени. Она сама переключает задачи, управляет приоритетами и распределяет ресурсы. Для RP2040 доступна FreeRTOS. Мы вернёмся к этой теме позже, когда освоим базовые паттерны.

## Машина состояний — логика внутри задачи

Мы разобрались, как запускать несколько задач параллельно. Но как организовать логику **внутри** одной задачи, если она сложнее простого «проверь и переключи»?

Рассмотрим пример: кнопка управляет режимами светодиода. Первое нажатие — светодиод горит постоянно, второе — мигает, третье — выключен, и так по кругу. Задача должна «помнить», в каком режиме она находится, и по-разному реагировать на одно и то же событие (нажатие кнопки). Для этого существует паттерн — **машина состояний**.

>[!NOTE] Определение
>**Машина состояний** (*англ. Finite State Machine, FSM*) — модель поведения, в которой система может находиться в одном из конечного числа **состояний**. Переход между состояниями происходит при наступлении определённых **событий**. В каждом состоянии система ведёт себя по-разному.

Компоненты машины состояний:
- **Состояния** (*states*) — дискретные режимы работы: «выключен», «горит», «мигает»
- **События** (*events*) — то, что вызывает переход: нажатие кнопки, истечение таймера, приход данных
- **Переходы** (*transitions*) — правила: «из состояния A по событию X перейти в состояние B»
- **Действия** (*actions*) — что делать при переходе или в текущем состоянии

### Пример: светодиод с тремя режимами

Рассмотрим следующую машину состояний:

![[Машина состояний.drawio.png]]

На языке C это реализуется через `enum` для состояний и `switch` для логики переходов:

```c
typedef enum
{
    LED_STATE_OFF   = 0,
    LED_STATE_ON    = 1,
    LED_STATE_BLINK = 2,
} led_state_t;

uint64_t led_ts = 0;
led_state_t led_state = LED_STATE_OFF;

void led_task_handle() {
    switch (led_state) {
        case LED_STATE_OFF:
            gpio_put(LED_PIN, 0);
            break;
        case LED_STATE_ON:
            gpio_put(LED_PIN, 1);
            break;
        case LED_STATE_BLINK:
			if (time_us_64() > led_ts)	
	        {	
	            led_ts = time_us_64() + (LED_BLINK_PERIOD_US / 2);	
	            bool state = gpio_get(LED_PIN);	
	            gpio_put(LED_PIN, !state);	
	        }
            break;
        default:
	        led_state = LED_STATE_OFF;
    }
}

void on_button_press(void) {
    switch (led_state) {
        case LED_STATE_OFF:   led_state = LED_STATE_ON;     break;
        case LED_STATE_ON:    led_state = LED_STATE_BLINK;  break;
        case LED_STATE_BLINK: led_state = LED_STATE_OFF;    break;
    }
}
```

Обратите внимание: `led_task_handle()` не знает про кнопку, а `on_button_press()` не знает про GPIO — они общаются только через переменную `led_state`. Это и есть разделение ответственности.

### Зачем машина состояний в микроконтроллере?

1. **Чёткая структура** — логика программы понятна и предсказуема
2. **Лёгкость отладки** — всегда известно текущее состояние системы
3. **Масштабируемость** — добавить новый режим = добавить `case` и переходы
4. **Неблокирующая работа** — FSM проверяет состояние и мгновенно возвращается, идеально для кооперативной многозадачности

>[!EXAMPLE] Пример
>Типичные применения FSM в микроконтроллерах:
>- Управление меню на дисплее (каждый экран — состояние)
>- Протоколы связи (ожидание → приём заголовка → приём данных → проверка)
>- Обработка кнопок с антидребезгом (отпущена → возможно нажата → нажата → возможно отпущена)
>- Автоматические системы (светофор, кофемашина, лифт)

## Задачи + машина состояний = архитектура

В реальном устройстве задачи и машины состояний дополняют друг друга. Каждая задача в планировщике — это, как правило, отдельная машина состояний:

```c
// Задача обработки кнопок — FSM для антидребезга
void task_button(void) {
    switch (button_state) {
        case BTN_RELEASED:
            if (gpio_get(BTN_PIN) == 0) button_state = BTN_MAYBE_PRESSED;
            break;
        case BTN_MAYBE_PRESSED:
            if (gpio_get(BTN_PIN) == 0) {
                button_state = BTN_PRESSED;
                on_button_press();   // сообщаем о нажатии
            } else {
                button_state = BTN_RELEASED;
            }
            break;
        case BTN_PRESSED:
            if (gpio_get(BTN_PIN) == 1) button_state = BTN_MAYBE_RELEASED;
            break;
        case BTN_MAYBE_RELEASED:
            if (gpio_get(BTN_PIN) == 1) button_state = BTN_RELEASED;
            else button_state = BTN_PRESSED;
            break;
    }
}

// Задача управления светодиодом — FSM с тремя режимами
void task_led(void) {
    switch (led_state) {
        case STATE_OFF:   gpio_put(LED_PIN, 0); break;
        case STATE_ON:    gpio_put(LED_PIN, 1); break;
        case STATE_BLINK: gpio_put(LED_PIN, !gpio_get(LED_PIN)); break;
    }
}

// Планировщик запускает обе задачи с нужной периодичностью
Task tasks[] = {
    {task_button, 20,  0},   // Кнопка — каждые 20 мс
    {task_led,    250, 0},   // Светодиод — каждые 250 мс
};
```

Планировщик вызывает задачи по расписанию. Каждая задача — неблокирующая FSM, которая проверяет своё состояние, делает нужное действие и мгновенно возвращается. Система остаётся отзывчивой, даже когда задач становится больше.

## Взаимодействие между задачами

Задачи работают независимо, но иногда им нужно обмениваться информацией. В примере выше `task_button` сообщает `task_led` о нажатии через вызов `on_button_press()`, которая меняет `led_state`. Простейший способ взаимодействия — **общая переменная с модификатором `volatile`**:

```c
volatile uint8_t button_event = 0;  // volatile — компилятор не оптимизирует доступ

void task_button(void) {
    // ... антидребезг ...
    if (/* кнопка подтверждённо нажата */) {
        button_event = 1;
    }
}

void task_led(void) {
    if (button_event) {
        button_event = 0;
        // переключить режим
    }
    // ... логика текущего режима ...
}
```


>[!NOTE] Из практики
>Даже сложные промышленные системы часто строятся именно так: набор задач с планировщиком, каждая задача — машина состояний, взаимодействие через флаги и общие переменные. Этот подход прост, предсказуем и хорошо масштабируется.

| **[[От ВПО к Устройству\|Предыдущий раздел]]** | [[Как начать писать код для микроконтроллера\|К занятию]] | |
| ---- | ---- | ---- |
