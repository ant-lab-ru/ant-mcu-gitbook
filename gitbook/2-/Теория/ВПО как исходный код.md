Мы обсудили, что у ВПО есть три формы: ВПО как код, ВПО как файл, ВПО как байты в памяти. В прошлый раз мы разобрались с последними двумя формами, и специально не углублялись в состав кода. Сейчас же разберемся какой набор кода нам нужен, чтобы ваша программа начала исполняться.

Давайте возьмём прошлый проект blink и пройдём последовательно от самых первых инструкций, исполняемых процессором, до самой главной строчки кода  — включение светодиода.

##  Код приложения (main.c)

Это самый главный файл `main.c`. В нём заложен функционал программы (в данном случае мигание светодиодом). 

```c
// подключаем библиотеки из pico SDK
#include "pico/stdlib.h"
#include "hardware/gpio.h"


// задаем константу с номером ножки, к которой подключен светодиод
// номер можно узнать и проверить в документации к плате
const uint LED_PIN = 25;

int main()
{

	// Инициализация STDIO
	stdio_init_all();
	// Инициализация GPIO вывода
	gpio_init(LED_PIN);
	gpio_set_dir(LED_PIN, GPIO_OUT);

	// Бесконечный цикл, чтобы светодиод мига все время
	while (1)
	{
		gpio_put(LED_PIN, 0);
		sleep_ms(250);
		gpio_put(LED_PIN, 1);
		sleep_ms(1000);
	}
}

```

Функционал устройства очень важное понятие, ведь ради него и делается наше устройство. Остальной код это лишь способ этот функционал реализовать. Стоит отметить, что по мере увеличения и усложнения функционала наша кодовая база будет расти, мы можем не держать весь код в одном файле, а распределять его по разным файлам. 

### Подключение внешнего кода

В самом начале `main.c` мы при помощи директивы препроцессора `include` подключаем все необходимые нам заголовочные файлы. В них содержится описание функций, а сам код компилируется отдельно из `*.c` файлов.  Всё что делает эта директива -- вставляет содержимое указанного файла. И всё. Но это инструмент, который позволяет строить  сложные системы из маленьких простых частей. Внутри этих двух файлов в свою очередь есть свои `include`, а внутри них свои и так далее. Вот, например, дерево подключения `pico/stdlib.h`:

```
main.c (27 строк)
└── pico/stdlib.h
    └── pico.h
        └── pico/types.h
            └── pico/assert.h
                ├── stdbool.h (компилятор)
                └── assert.h (newlib)
                    └── _ansi.h
                        ├── newlib.h
                        └── sys/config.h
            └── stdint.h (компилятор)
                └── stdint.h (newlib)
                    └── machine/_default_types.h  ← Здесь определяются базовые типы!
                    └── sys/_stdint.h             ← Здесь typedef uint8_t, uint32_t
        └── pico/version.h
        └── pico/config.h
    └── hardware/gpio.h
        └── hardware/structs/sio.h   ← Структура для работы с GPIO
        └── hardware/structs/iobank0.h
    └── hardware/uart.h
    └── pico/time.h
```

Вставками кода занимается препроцессор. И после окончания его работы файл  содержит в себе **3622 строки**! И это только объявления типов, структур и inline-функций. 

>[!NOTE] Попробуйте
> Если вам интересно посмотреть на этот файл, можете сами получить его при сборке. Для этого лишь надо сказать компилятору, чтобы он не удалял результаты препроцессинга.
> 
> Для этого добавьте в `CMakeLists.txt` после требования к минимальной версии, строчку
> ```
> set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -save-temps=obj")
> ```
> И после выполнения сборки по пути `build\СMakeFiles\01_blink.dir\main.c.i` будет лежать файл после препроцессинга

Поэтому всегда, думайте, что вы подключаете в свой `main.c`

### Объявление типов и констант

Дальше в нашем main.c мы объявили константу LED_PIN. Остановимся на том, как вообще объявляются типы и константы в наших исходных файлах. 

Все, что написано в `*.c` файлах вне кода функций по умолчанию видно лишь функциям внутри этого файла (это ограничение можно обойти, но об этом в другой раз). Это важное свойство позволяет скрывать нам от других участков кода детали реализации. Это похоже на использование  модификатора доступа `private`, но только при программировании ВПО. Если же вы хотите, чтобы ваши типы и константы были видны другом участкам кода, как будто они `public`, то необходимо объявлять их внутри `*.h` файлов. Тогда при подключении директивой `include` они автоматически попадут в другие `*.c` файлы. У этого есть и обратная сторона, если названия таких констант или типов совпадут, то появится ошибка, которую придется искать.

>[!NOTE] Из практики
>В одном из проектов нашей лаборатории мы подключали библиотеку, которая имела константу названную OK = 1. А внутри своего кода мы использовали константу OK = 0. И были очень удивлены, когда наши библиотеки начали возвращать значения отличные от OK. Поиск ошибки занял два дня.

> [!ATTENTION] Внимание!
> Компилятор оптимизирует код, чтобы не использовать лишние данные в памяти микропроцессора. Поэтому если Вы подключили  директивой ```include``` код, которые не будет использован, то компилятор его удалит
Для начала нам нужно проинициализировать все необходимые нам модули микроконтроллера. В нашем примере это: 
### Функция main()

Как вы уже поняли, функция main это далеко не самая большая часть нашей прошивки. Тем не менее она крайне важна. Это отправная точка функционала нашего устройства. Именно здесь мы решаем какие модули будем использовать.

- `stdio_init_all()` — инициализация подсистемы ввода-вывода (для отладочного вывода)
- `gpio_init(LED_PIN)` — инициализация блока GPIO для конкретного пина
- `gpio_set_dir(LED_PIN, GPIO_OUT)` — настройка пина как выхода  

По мере усложнения проекта список инициализаций будет расти: настройка тактирования, таймеров, интерфейсов связи (UART, SPI, I2C), прерываний и других модулей. Здесь нужно иметь в виду, что некоторые аппаратные модули опираются на другие и важно соблюдать порядок. Первым обычно настраивается тактирование, так как оно требуется всем модулям. Если вы хотите использовать `printf` для вывода, то сначала нужно инициализировать подсистему вывода.

После того, как все необходимые нам аппаратные модули работают, мы можем перейти к приложению. Поскольку, если модуль дойдёт до конца функции main, то исполнение программы завершится, в ВПО существует концепция **суперцикла**

>[!NOTE] Определение
**Суперцикл** (*англ. super loop, main loop, infinite loop*) — архитектурный паттерн встроенного программного обеспечения, при котором основная логика приложения выполняется внутри бесконечного цикла, обеспечивающего непрерывную работу программы до отключения питания или перезагрузки системы.

Внутри суперцикла выполняются регулярные задачи опроса модулей, отслеживания их состояний и передачи информации. 



| **Начало** | [[Как начать писать код для микроконтроллера\|К занятию]] | **[[Цепочка загрузки RP2040\|Следующий раздел]]** |
| ---------- | ------------------------------------------------------- | ------------------------------------------------------ |
