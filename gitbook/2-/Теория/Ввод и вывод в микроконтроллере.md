
В прошлых разделах мы разобрались с составом кода, цепочкой загрузки и организацией памяти. Но вот вы написали `printf("Hello\n")` — и что дальше? Куда уходят эти байты, если у микроконтроллера нет монитора?

На Raspberry Pi всё было просто: вы открывали терминал прямо на рабочем столе, запускали скрипт и видели результат. Операционная система сама заботилась о том, чтобы `print()` в Python попал на экран. В микроконтроллере ОС нет, экрана нет, и если не позаботиться о выводе заранее — `printf` просто ничего не сделает. Давайте разберёмся, как устроен ввод-вывод на RP2040 и почему путь от строчки кода до текста в терминале не так уж тривиален.

## Микроконтроллер без экрана — куда выводить?

У микроконтроллера нет дисплея и нет операционной системы, которая подставит «окно» для вывода. Для отладки и обмена данными нужен **интерфейс связи с компьютером** — последовательный канал, по которому байты уходят наружу.

>[!NOTE] Определение
>**Последовательный интерфейс** (*англ. serial interface*) — способ передачи данных, при котором биты отправляются один за другим по одной или нескольким линиям. В контексте микроконтроллеров это обычно UART или USB.

Именно поэтому в задании [[Hello World!]] мы подключаемся к микроконтроллеру через терминал PuTTY — он и есть наш «экран» для прошивки.

## printf как абстракция

`printf` — стандартная функция языка C из заголовка `stdio.h`. Она форматирует строку и передаёт её «куда-то». На ПК это «куда-то» — окно терминала, в Linux — файловый дескриптор stdout. Вы об этом даже не задумываетесь, потому что операционная система сама подставляет нужное назначение.

Во встраиваемой системе всё иначе: операционной системы нет, и программист должен явно указать, куда направить поток вывода. Без этого `printf` попросту ничего не сделает — он отформатирует строку и вызовет функцию записи, которая по умолчанию является заглушкой.

## От printf к железу: цепочка вызовов

Как именно байты из вашего кода попадают в терминал? Путь состоит из нескольких шагов:

1. `printf("Hello\n")` форматирует строку в последовательность байтов: `0x48 0x65 0x6C 0x6C 0x6F 0x0A`
2. Вызывается низкоуровневая функция `_write()`. В стандартной библиотеке C (newlib) она по умолчанию ничего не делает — это заглушка. Pico SDK предоставляет свою реализацию, которая передаёт данные в выбранный backend: UART или USB
3. Backend вызывает драйвер периферии — записывает байты в регистры соответствующего аппаратного модуля через memory-mapped I/O (ту самую идею, о которой мы говорили в контексте [[Устройство микроконтроллера|устройства микроконтроллера и системной шины]])
4. Аппаратный модуль отправляет данные по кабелю на компьютер
5. Терминал (PuTTY, minicom) читает данные из COM-порта и показывает текст на экране

Вот как это выглядит в виде схемы:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              ПУТЬ ОТ printf ДО ТЕРМИНАЛА                                   │
└─────────────────────────────────────────────────────────────────────────────┘

    printf("Hello\n")
              │
              ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  Форматирование строки (newlib)                                     │
    │  "Hello\n" → байты 0x48 0x65 0x6C 0x6C 0x6F 0x0A                   │
    └─────────────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  _write() — реализация Pico SDK                                    │
    │  Передаёт байты в backend stdio (UART или USB)                      │
    └─────────────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  Драйвер периферии (USB CDC или UART)                               │
    │  Запись в регистры модуля (memory-mapped I/O)                       │
    └─────────────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  USB‑кабель → компьютер → виртуальный COM‑порт                     │
    └─────────────────────────────────────────────────────────────────────┘
              │
              ▼
    ┌─────────────────────────────────────────────────────────────────────┐
    │  Терминал (PuTTY, minicom) открывает порт → текст на экране         │
    └─────────────────────────────────────────────────────────────────────┘
```

## Роль stdio_init_all()

Как вы помните из [[ВПО как исходный код]], порядок инициализации важен. Функция `stdio_init_all()` инициализирует подсистему ввода-вывода: она настраивает backend (UART или USB) как «устройство» для stdout и stderr. Без вызова этой функции перед первым `printf` драйвер периферии не будет готов — байты просто некуда передать, и вы не увидите никакого вывода.

Правило простое: **сначала `stdio_init_all()`, потом `printf`**. Нарушите порядок — потеряете первые сообщения.

## Два варианта вывода: UART и USB CDC

В Pico SDK можно выбрать, куда пойдёт поток stdio. У каждого варианта свои особенности.

>[!NOTE] Определение
>**UART** (*Universal Asynchronous Receiver-Transmitter*) — классический последовательный интерфейс, передающий данные побайтово с фиксированной скоростью (baudrate) по двум линиям: TX (передача) и RX (приём).

>[!NOTE] Определение
>**USB CDC** (*USB Communications Device Class*) — стандарт, позволяющий микроконтроллеру представляться компьютеру как виртуальный COM-порт через обычный USB-кабель. Данные передаются пакетами по высокоскоростному протоколу USB.

| Вариант | Описание | Настройка в CMakeLists.txt |
|---------|----------|----------------------------|
| **UART** | Пины TX/RX, фиксированная скорость (baudrate). Для связи с ПК нужен отдельный USB‑UART‑адаптер | `pico_enable_stdio_uart(target 1)` |
| **USB CDC** | Виртуальный COM‑порт через встроенный USB. Подключение тем же кабелем, что для прошивки. Дополнительный адаптер не нужен | `pico_enable_stdio_usb(target 1)` |

В нашем курсе мы используем USB CDC. Плата Pico подключается тем же кабелем, что и для записи прошивки — никакого дополнительного оборудования не требуется.

>[!NOTE] Из практики
>Если вы смотрите настройки в PuTTY и видите поле «Скорость» (baudrate) — при работе через USB CDC его можно не менять. USB передаёт данные пакетами по высокоскоростному протоколу, а не побайтово с фиксированной скоростью, как UART. Поле baudrate для USB CDC существует «для совместимости», но фактически не влияет на скорость передачи.

## Аппаратная часть пути

Когда мы говорим «записать байты в регистры», мы имеем в виду memory-mapped I/O: программа пишет по определённому адресу в адресном пространстве, а на самом деле управляет периферией. Мы уже сталкивались с этой идеей в разделе про [[Память в ВПО|память]].

При использовании USB CDC данные попадают в буферы передачи, USB‑контроллер RP2040 формирует пакеты и отправляет их по USB‑кабелю. На стороне компьютера драйвер создаёт виртуальный COM-порт, а терминал открывает его и показывает принятые байты как текст. Всё это происходит автоматически — Pico SDK скрывает детали реализации USB-стека от нас.

## Ввод — та же цепочка в обратную сторону

Ввод работает по зеркальной схеме: вы нажимаете клавишу в терминале → байт отправляется в COM‑порт → по USB попадает в RP2040 → `getchar()` или `scanf()` получает символ. Это основа задания [[Echo в COM‑порте]], где микроконтроллер возвращает обратно то, что вы ввели.

| **[[Память как инструмент\|Предыдущий раздел]]** | [[Как начать писать код для микроконтроллера\|К занятию]] | **[[Время внутри микроконтроллера\|Следующий раздел]]** |
| ---------------------------------------------- | ------------------------------------------------------- | ------------------------------------------ |
