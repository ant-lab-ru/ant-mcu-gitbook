

После того, того как мы разобрались со всеми деталями нашего кода пора превратить эти теоретические знания в практические инструменты, которые дадут нам больше возможностей для разработки ВПО.

Раз память настолько важна в ВПО, то это большая ответственность, а к большой отвественности должна прилагаться большая сила. И в языке C этой силой являются указатели.
## Указатели на переменные и константы

Мы уже знаем, где лежат код, константы и переменные — линкер-скрипт и карта памяти это определяют. Теперь превратим эти знания в инструмент.

**Оператор взятия адреса** `&` возвращает адрес объекта в памяти. Применим его к нашей константе:

```c
&LED_PIN
```

Мы получим адрес ячейки, где хранится значение 25. В C нельзя разыменовать числовой литерал напрямую, т.е. нельзя написать 
```c
&25 // некорректное использование оператора взятия адреса
```
поэтому для работы с адресом заводим указатель — переменную, хранящую адрес:

```c
const uint32_t* ptr = &LED_PIN;
uint32_t value = *ptr;
```

Здесь `ptr` указывает на LED_PIN, а `*ptr` — это **разыменование**: мы берём значение по адресу из `ptr`.

**Обратная задача**: если известен точный адрес в памяти, можно получить значение. На RP2040 32-битная система, адреса 32-битные, их обычно записывают в HEX. Например, если адрес LED_PIN — `0x10001E28`, то значение можно прочитать так:

```c
uint32_t value = *(uint32_t*)0x10001E28;
```

Выражение `(uint32_t*)0x10001E28` — приведение адреса к типу указателя на `uint32_t`, а `*` перед ним — разыменование. Тип обязан совпадать с типом данных по этому адресу: если LED_PIN — 32-битное число, нужен указатель на `uint32_t`. С меньшим типом получим только часть числа, с большим — захватим лишние байты.

Иногда данные по адресу могут меняться без участия процессора — например, в регистрах периферии. Тогда компилятор не должен оптимизировать доступ. Для этого используют модификатор `volatile`:

```c
uint32_t reg_value = *(volatile uint32_t*)0x40014000;
```

При работе с регистрами GPIO и другой периферией `volatile` обычно обязателен. Библиотеки вроде Pico SDK уже используют его внутри.

> [!NOTE] Важно!
> При доступе по фиксированному адресу вы должны быть уверены, что по нему лежит именно ожидаемый тип данных — переменная или регистр, а не код функции или «чужая» память. Ошибка может привести к неопределённому поведению или аварийному завершению. В некоторых микроконтроллерах есть защита от записи в исполняемую память, но полагаться на неё не стоит.

## Указатели на структуры

При работе с указателями важно корректно преобразовывать тип: слишком маленький тип даст лишь часть значения, слишком большой — захватит лишние байты. Со структурами это критично — важно не только общее число байт, но и то, как поля расположены в памяти.

Процессор ARM Cortex-M0 удобнее работает с данными, выровненными по границам 4 байт. Компилятор автоматически добавляет между полями **выравнивание** (*padding*) — пустые байты, чтобы каждое поле начиналось с подходящего адреса. В результате размер структуры может оказаться больше суммы размеров полей:

```c
typedef struct {
    uint32_t LED_PIN;
    uint32_t BUTTON_PIN;
} pins_t;

pins_t my_pins = { .LED_PIN = 25, .BUTTON_PIN = 12 };
```

Здесь оба поля по 4 байта, структура занимает 8 байт. Но если добавить поле `uint8_t flag`, компилятор может вставить 3 байта после него, чтобы следующее поле выровнялось по 4 байтам. Функция `sizeof(pins_t)` возвращает итоговый размер с учётом паддинга, а макрос `offsetof(pins_t, LED_PIN)` — смещение поля относительно начала структуры.

Указатель на структуру объявляется как `pins_t*`:

```c
pins_t* p = &my_pins;
gpio_put(p->LED_PIN, 1);
gpio_init(p->BUTTON_PIN);
```

Оператор `->` заменяет `(*p).LED_PIN`: сначала разыменование, затем доступ к полю. При приведении к `(uint32_t*)` вы получаете указатель на первое поле; остальные поля находятся по смещениям, заданным `offsetof`.

Если структура должна точно соответствовать размерам полей (например, при обмене по протоколу или при работе с регистрами периферии), используют директиву `#pragma pack`:

```c
#pragma pack(push, 1)
typedef struct {
    uint8_t  cmd;
    uint16_t value;
    uint32_t timestamp;
} packet_t;
#pragma pack(pop)
```

`#pragma pack(push, 1)` сохраняет текущие настройки и задаёт выравнивание по 1 байту — padding отключается. `#pragma pack(pop)` восстанавливает прежние настройки. Без pack структура могла бы занять 12 байт (1 + 1 padding + 2 + 2 padding + 4), с pack — 7 байт. Это экономит память, но может замедлить доступ на некоторых архитектурах.

> [!NOTE] Совет
> Используйте `#pragma pack` осознанно: для структур протоколов и дескрипторов — уместно, для часто используемых структур в коде — чаще лучше оставить выравнивание по умолчанию.

## Указатели на функции

Каждая функция лежит в памяти по своему адресу — имя функции по сути является указателем на её первый байт. Значит, если мы знаем адрес, можем вызвать код по нему. Но для этого нужна **сигнатура** функции: типы аргументов и тип возвращаемого значения. Эта информация задаёт тип указателя на функцию. Пример:

```c
int add(int a, int b)
{
    return a + b;
}

typedef int (*add_ptr_t)(int, int);

int main()
{
    add_ptr_t add_func = (add_ptr_t)0x10001A00;
    int result = add_func(2, 2);
}
```

Запись `typedef int (*add_ptr_t)(int, int)` объявляет тип `add_ptr_t` — указатель на функцию, принимающую два `int` и возвращающую `int`. При присвоении адреса используется явное приведение `(add_ptr_t)0x10001A00`. Вызов `add_func(2, 2)` делает то же самое, что и вызов `add(2, 2)`.

Что при этом делает процессор? Если аргументов меньше четырёх, то аргументы передаются в регистрах R0–R3. Если больше, то значения передаются через стек. У стека очень большая роль в вопросе вызова функций. Роль стека — хранение адреса возврата, локальных переменных и аргументов, если их больше четырёх. Общая последовательность: сохранить адрес возврата, положить аргументы в регистры (или стек), перейти по адресу функции, выполнить её, вернуть результат в регистр R0, восстановить адрес возврата и продолжить выполнение.

И так как мы знаем, что функция это лишь адрес, то мы можем передать этот адрес другой функции. **Передача функции как параметра** — типичный приём для обработчиков событий и таймеров. Функция принимает «что делать» и вызывает это по указателю. Обычно такая функция передаваемая как параметр называется **callback**. Вот пример вызова callback по истечению с задержкой.

```c
typedef void (*callback_t)(void);

void run_after_delay(uint32_t ms, callback_t callback)
{
    sleep_ms(ms);
    if (callback != NULL) {
        callback();
    }
}

void on_timeout(void) 
{ 
	gpio_put(LED_PIN, 1); 
}

int main()
{
    run_after_delay(1000, on_timeout);
}
```

Проверка `callback != NULL` перед вызовом защищает от перехода по нулевому адресу.

**Массив указателей на функции** описывает набор действий по индексу. Яркий пример — **таблица векторов** в стартап-коде: по фиксированным смещениям лежат адреса обработчиков прерываний. Процессор получает номер прерывания и переходит по соответствующему адресу из этой таблицы. Аналогично можно организовать свою диспетчеризацию:

```c
typedef void (*handler_t)(void);
handler_t handlers[] = { handle_idle, handle_run, handle_error };

void dispatch(uint8_t state)
{
    if (state < sizeof(handlers) / sizeof(handlers[0])) {
        handlers[state]();
    }
}
```

Загрузчик второй стадии передаёт управление в `main` по тому же принципу: он знает адрес точки входа и вызывает её как функцию. Указатели на функции позволяют исполнять код из любой области памяти, передавать обработчики в другие функции и строить гибкие таблицы вызовов — от таблицы векторов до диспетчеров состояний.

Как только память и указатели становятся не просто адресами, а инструментом разработки, то в микроконтроллере почти не остаётся области, к которой нельзя было бы обратиться осознанно.

| **[[Память в ВПО\|Предыдущий раздел]]** | [[Как начать писать код для микроконтроллера\|К занятию]] | **[[Ввод и вывод в микроконтроллере\|Следующий раздел]]** |
| ---------- | ------------------------------------------------------- | ------------------------------------------------------ |
