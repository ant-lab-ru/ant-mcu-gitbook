
Вопросы памяти при разработке ВПО являются одними из самых важных. ***Во-первых**,* потому что её обычно мало. ***Во-вторых**,* память это основное средство обмена данными между процессором и периферией, поэтому постоянно необходимо думать куда положить данные от периферии, чтобы процессор мог быстро их взять и обработать. ***И в-третьих,*** для процессора весь мир — это память, а значит в любой момент при вашей ошибке он может начать писать данные вместо памяти в регистры периферийных модулей, которые также связаны с ним по системной шине памяти, и тогда работоспособность вашего устройства будет под вопросом. И хорошо если вы узнаете об этом в процессе отладки, а не когда ваше устройство улетит в космос.

Перейдём к пожалуй самой сложной части всего нашего кода,  **к линкер-скрипту**. Это инструкции для программы компоновщика. По сути, всё что он делает это определяет в каких частях памяти будет лежать код, переменные, стек (подробнее о нем ниже) и так далее. Линкер-скрипт написан на отдельном языке. Написание линкер-скрипта это мастерство. Написание сложных линкер-скриптов это искусство. Мы не сможем в рамках курса разобраться со всеми нюансами создания линкер-скрипта, но попытаемся кратко описать самые важные части.

В начале идёт описание **MEMORY**, в котором размечены все регионы памяти, с которыми будет работать наше ВПО. Там описаны их стартовые адреса, размеры и имена.

Ниже код для проект blink, но c добавлением несколько переменных для наглядности дальнейших примеров.

```c
#include "pico/stdlib.h"
#include "hardware/gpio.h"

// Глобальная константа
const uint LED_PIN = 25;

// Глобальная переменная (инициализированная)
uint32_t blink_count = 0;

// Глобальная переменная (неинициализированная)
uint32_t last_time;

int main()
{
    // Локальная переменная
    uint32_t delay = 250;

    stdio_init_all();
    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);

    while (1)
    {
        gpio_put(LED_PIN, 0);
        sleep_ms(delay);
        gpio_put(LED_PIN, 1);
        sleep_ms(delay * 4);
        blink_count++;
    }
}
```

Далее в разделе **SECTIONS** описывают различные секции памяти. Обычно их названия начинаются с точки, после чего в фигурных скобках указываются различные параметры секции. В самом конце указывается в каком регионе памяти будет располагаться данная секция. 
- Cекция `.boot2` определяет расположение загрузчика второй стадии во **FLASH**. 
- Cекция `.text`, в ней хранится код main и код SDK, эта секция также располагается во **FLASH**. 
- Секция `.rodata`, в ней хранятся константы. Созданная нами переменная `LED_PIN` может хранится именно там, поскольку не будет изменятся в ходе программы, она размечена в **FLASH**.
- Секция `.data`, в ней описано, где будут храниться глобальные переменные. Обычно размечена в **SRAM**, поскольку значение глобальных может меняться в процессе работы. У этих переменных будет постоянный адрес во время всей работы программы.
- Секция ```.bss```, в ней хранятся неинициализированные глобальные переменные. Она нужна для того, чтобы перед стартом программы стартап-код записал туда нулевые значения.
На самом деле, такие таких секций может быть больше и они могут быть сложнее, но общие принципы остаются.

>[!NOTE] Определение
>Где же окажутся переменные?

| Переменная    | Тип                            | Секция    | Область памяти |
| ------------- | ------------------------------ | --------- | -------------- |
| `LED_PIN`     | `const uint`                   | `.rodata` | Flash          |
| `blink_count` | `uint32_t = 0`                 | `.data`   | SRAM           |
| `last_time`   | `uint32_t` (без инициализации) | `.bss`    | SRAM           |
| `delay`       | локальная `uint32_t`           | —         | Стек (SRAM)    |

Еще одна важная часть этого скрипта — разметка кучи и стека.

>[!NOTE] Определение
> **Куча** (*англ. Heap*) — область памяти для динамического выделения во время выполнения программы. Управляется программистом через malloc()/free().

Куча нам нужна, чтобы хранить данные о существовании которых мы не можем знать в процессе компиляции программы. Например, если о длине массива мы узнаем только от пользователя (например, требуемый размер окна данных считанных из АЦП), то его необходимо будет создать в куче при помощи команды `malloc`. После того, как пользователь решит, что он больше не будет пользоваться этим массивом, то мы можем вызвать `free` и освободить и так не очень большой объем памяти. Вообще еще одной большой задачей для разработчика ВПО является определение того, какие массивы данных стоит определить на этапе компиляции и тогда они попадут в секцию `.data`, а какие можно будет создать уже в процессе выполнения программы и тогда они разместятся в куче. Кучу контролирует аллокатор памяти, который находит свободные места в куче и удаляет ненужные данные.

>[!NOTE] Определение
>**Стек** (*англ. Stack*) — область памяти для хранения локальных переменных, адресов возврата из функций и сохранённых регистров. Работает по принципу LIFO (Last In, First Out).


Стек нам нужен, чтобы программа вообще могла функционировать. Если без кучи можно работать и просто сохранить все переменные и массивы в секции данных, то без стека невозможен даже вызов функций. В нём хранятся локальные переменные, адреса возврата из функций, аргументы функций и сохраняются регистры процессора. Он настолько важен, что внутри ядра процессора есть отдельный регистр быстрой памяти, в котором хранится указатель на его конец (SP - Stack Pointer). Начало стека и его границы определяются в линкер-скрипте. Стек растёт с максимального адреса до минимального. Как только вы создадите слишком много переменных или вызовете слишком много вложенных функций произойдёт самый большой страх разработчика ВПО — переполнение стека или **Stack Overflow**. В таком случае, вам придётся либо искать в каком месте происходит большое выделение памяти, либо где слишком большая вложенность функций. Так как в RP2040 два ядра, соответственно там два стека.

Ниже представлена схема секций.
![[РазметкаПамяти.drawio.png]]

| **[[Цепочка загрузки RP2040\|Предыдущий раздел]]** | [[Как начать писать код для микроконтроллера\|К занятию]] | **[[Память как инструмент\|Следующий раздел]]** |
| ---------- | ------------------------------------------------------- | ------------------------------------------------------ |
