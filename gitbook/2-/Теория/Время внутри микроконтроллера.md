Мы разобрались с вводом и выводом, с памятью и кодом. Но в blink вы уже видели `sleep_ms(250)` — откуда микроконтроллер знает, сколько прошло времени, и как вообще с ним работать?

В микроконтроллере нет полноценной ОС. На Raspberry Pi с Linux вы могли вызывать `sleep()` и полагаться на планировщик задач. Здесь одна программа крутится в бесконечном цикле. Задержки, измерение интервалов, периодические действия — всё это ложится на плечи разработчика и аппаратных таймеров.

## Тактовый сигнал и осциллятор

Откуда вообще берётся время в микроконтроллере? Всё начинается с **тактового сигнала**.

>[!NOTE] Определение
>**Тактовый сигнал** (*англ. clock*) — периодическая последовательность электрических импульсов, которая синхронизирует все операции в микроконтроллере. Один такт — одна атомарная операция: одна инструкция процессора, один шаг счётчика таймера.

Физически этот сигнал генерирует **осциллятор** (*англ. oscillator*) — источник стабильных колебаний. На плате Raspberry Pi Pico рядом с микросхемой RP2040 можно увидеть маленький серебристый прямоугольник — это **кварцевый резонатор** (*англ. quartz crystal*). Он работает на основе пьезоэлектрического эффекта: при подаче напряжения кварцевая пластинка механически колеблется, эти колебания превращаются в электрический сигнал, который снова усиливается и подаётся на резонатор — возникает автоколебание. Частота определяется физическими размерами кристалла и очень стабильна. Именно поэтому кварц — основа точного времени не только в микроконтроллерах, но и в часах, приёмниках и измерительных приборах.

В RP2040 используется внешний кварцевый резонатор на 12 МГц. Внутри чипа есть усилитель и схема, которая вместе с кварцем образует **кварцевый генератор** (*XOSC, англ. crystal oscillator*). 

![[pi_pico.PNG]]

Если вы возьмете осциллограф и подключите его к одной из ножек кварцевого генератора в при включенном питании, то увидите такой сигнал. Его частота равна 12МГц

![[clock.bmp]]

Но наш процессор работает на частоте 133 МГц — как повысить частоту изначального физического колебания? Для этого внутри микроконтроллера есть особые аппаратные модули **PLL** (*Phase-Locked Loop*). Благодаря физическому устройству они позволяют менять параметры тактового сигнала в некоторых пределах. Мы можем повысить частоту или понизить её, сдвинуть фазу вперёд или назад. Но у этих операций, конечно же, есть физические пределы (не получится из 12 МГц получить 3 ГГц). Так как тактовый сигнал на конкретной частоте необходим любому аппаратному модулю внутри микроконтроллера — настройка PLL является одним из первых действий при инициализации.
## Монотонное время — «линейное» время на борту

Внутри RP2040 есть **монотонный счётчик** (*англ. monotonic counter*). Он начинается с нуля при включении и просто увеличивается. Не путать с RTC (реальным временем, часами и минутами): монотонный счётчик не знает «который час», он знает только «сколько прошло с момента старта».

>[!NOTE] Определение
>**Монотонное время** — счётчик, который не уменьшается и не откатывается назад. Идеально подходит для измерения интервалов и проверки «прошло ли уже N единиц времени».

В Pico SDK доступны функции из `pico/time.h` (который подключается через `pico/stdlib.h`):

- `time_us_64()` — возвращает число микросекунд с момента включения. 64 бита, переполнение не проблема даже через сотни лет.
- `time_us_32()` — то же в младших 32 битах. Удобно для коротких интервалов, но примерно через 71 минуту происходит переполнение.

Для работы с точками во времени SDK предлагает тип `absolute_time_t` и функции `get_absolute_time()`, `absolute_time_diff_us()`.

```c
absolute_time_t start = get_absolute_time();
// ... выполняем какие-то действия ...
if (absolute_time_diff_us(start, get_absolute_time()) > 1000) {
    // прошла тысяча микросекунд
}
```

## Пассивные задержки: sleep_ms() и sleep_us()

Самый простой способ подождать — `sleep_ms()` и `sleep_us()`. Процессор «засыпает» на заданное время и не выполняет никакой другой логики. Именно так работает blink: `gpio_put(LED_PIN, 0); sleep_ms(250);` — светодиод гаснет, программа ждёт четверть секунды, затем снова включает светодиод.

Удобно для мигания светодиодом или паузы между командами. Но есть важное ограничение: **пока идёт sleep, программа не реагирует ни на что**. Ввод с клавиатуры, прерывания, другие события — всё будет ждать, пока задержка не закончится.

## Таймер как периферия

Откуда берётся монотонное время? Таймер — это **аппаратный модуль**: счётчик, который тикает от системного тактового сигнала. Его значение можно читать и сравнивать. Как и GPIO или UART, таймер — это периферия, доступная через memory-mapped регистры по системной шине. Процессор просто читает нужный адрес — и получает текущее значение счётчика.

Именно из этого аппаратного таймера берётся монотонное время для `time_us_64()` и `get_absolute_time()`. SDK не даёт вам напрямую менять этот счётчик: он должен оставаться монотонно растущим, иначе перестанут корректно работать задержки, alarm'ы и таймауты.

## Аппаратные таймеры-будильники (Alarms)

Когда нужно «проснуться через N микросекунд», но при этом не блокировать выполнение, используются **аппаратные будильники** (*англ. alarm timers*). RP2040 имеет четыре независимых alarm'а. Вы задаёте момент времени в будущем — и когда он наступает, вызывается callback (или срабатывает прерывание). В отличие от sleep, программа может продолжать делать что-то другое, пока ждёт.

```c
#include "pico/stdlib.h"

int64_t blink_callback(alarm_id_t id, void *user_data) {
    gpio_put(25, !gpio_get(25));
    return 500000;  // повторить через 500000 мкс (0.5 сек)
}

int main() {
    gpio_init(25);
    gpio_set_dir(25, GPIO_OUT);
    add_alarm_in_ms(500, blink_callback, NULL, true);
    while (1) {
        tight_loop_contents();  // можно делать что угодно
    }
}
```

Alarm'ы объединяются в пулы (alarm pool). По умолчанию один пул уже создан и использует один из четырёх аппаратных alarm'ов. Подробнее — в документации `hardware/alarm.h` и `pico/time.h`.

## RTC — часы реального времени

Раньше мы говорили: монотонный счётчик не знает «который час». Но иногда нужно именно «реальное» время — дата, часы, минуты, секунды. Для этого в RP2040 есть **RTC** (Real Time Clock).

>[!NOTE] Определение
>**RTC** (*англ. Real Time Clock*) — периферийный модуль, который отсчитывает календарное время: год, месяц, день, час, минута, секунда.

RTC в RP2040 — это отдельный аппаратный модуль с собственным счётчиком. Он питается от того же кварца, что и вся система, но считает «человеческими» единицами. В Pico SDK доступны функции `rtc_init()`, `rtc_set_datetime()`, `rtc_get_datetime()` из `hardware/rtc.h`. Время задаётся в структуре `datetime_t` (год, месяц, день, час, минута, секунда).

Важный нюанс: **у RP2040 нет резервной батареи для RTC**. При отключении питания время теряется — при следующем включении RTC придётся снова установить. Поэтому часто у микроконтроллеров есть отдельная ножка, к которой можно подключить питание для RTC, чтобы он не сбрасывался.

| Задача                                            | Инструмент                                                           |
| ------------------------------------------------- | -------------------------------------------------------------------- |
| Простая задержка (мигание, пауза)                 | `sleep_ms()` / `sleep_us()`                                          |
| Измерение интервалов, проверка «прошло ли»        | `time_us_64()` или `get_absolute_time()` + `absolute_time_diff_us()` |
| Ожидание без блокировки (можно делать что-то ещё) | Alarm'ы (`add_alarm_in_us`, `add_alarm_in_ms`)                       |
| Дата и время «как на часах»                       | RTC (`hardware/rtc.h`)                                               |

Теперь мы понимаем, откуда микроконтроллер берёт время и какие инструменты есть для работы с ним — от простых задержек до аппаратных будильников. В [[От ВПО к Устройству|следующем разделе]] мы посмотрим, как все изученные нами элементы — код, память, ввод-вывод и время — складываются в законченное устройство.

| **[[Ввод и вывод в микроконтроллере\|Предыдущий раздел]]** | [[Как начать писать код для микроконтроллера\|К занятию]] | **[[От ВПО к Устройству\|Следующий раздел]]** |
| ------------------------------------------------------- | ------------------------------------------------------- | -------------------------------------------- |
