---
занятие:
  - "[[Как начать писать код для микроконтроллера]]"
дата: 2026-02-11
tags:
  - занятие2
  - теория
---

В прошлых разделах мы разобрались с кодом, памятью, вводом-выводом и временем. Наш blink мигает, мы можем выводить текст в терминал и замерять интервалы. Но выполняет ли наша прошивка свою задачу так, как задумано? Какой бы красивый код мы ни написали, важно лишь одно — справляется ли он с функционалом устройства. В этом разделе проследим путь от «просто кода» к полноценному устройству.

## Функционал устройства

В [[ВПО как исходный код|первом разделе]] мы говорили, что функционал — это то, ради чего делается устройство. В blink это мигание светодиодом. В более сложной системе — опрос датчиков, управление исполнительными механизмами, обмен данными с компьютером. Остальной код — лишь способ этот функционал реализовать.

>[!NOTE] Определение
>**Функционал устройства** — набор возможностей, которые устройство предоставляет пользователю или системе. Определение функционала — один из первых этапов разработки встраиваемой системы.

Одна из главных задач устройства — возможность **обмениваться информацией** с теми, кто им пользуется. Без этого наша прошивка остаётся замкнутой: мы не знаем, что происходит внутри, не можем отдать команду, не можем получить результат. Как только появляется обмен — появляется пользователь.

## Пользователь системы

На Raspberry Pi вы запускали Python-скрипт и видели результат прямо в терминале на мониторе. Пользователь — это вы, сидящий за клавиатурой. Но в мире встраиваемых систем пользователем может быть не только человек. Это любая сущность, которая взаимодействует с устройством:

- **Человек** — через терминал, кнопки, дисплей
- **Другая встраиваемая система** — датчик, исполнительный механизм, другой микроконтроллер
- **Приложение на ПК** — скрипт на Python, программа настройки, система сбора данных

Во всех случаях для обмена нужен **интерфейс** — точка соприкосновения устройства с внешним миром. А чтобы обмен был осмысленным, нужен **протокол** — правила, по которым стороны договариваются общаться.

## От интерфейса к протоколу

Итак, у нас есть пользователь и интерфейс. В микроконтроллере интерфейсы — это GPIO, UART, SPI, I2C, USB. Мы подробно разбирали путь от `printf` до терминала в разделе [[Ввод и вывод в микроконтроллере]]. Но интерфейс лишь передаёт байты. Что, если микроконтроллер получил байт `0x31` — это команда? Данные? Ошибка? Без договорённости — непонятно. Чтобы байты имели смысл, нужны правила обмена.

>[!NOTE] Определение
>**Протокол** (*англ. protocol*) — набор правил, определяющих формат, порядок и значение передаваемых данных. Протокол задаёт, как различаются команды и ответы, в каком порядке идут байты и как обнаружить ошибку.

Рассмотрим на конкретном примере. Допустим, наше устройство умеет управлять светодиодом — включать, выключать и мигать. Самый простой протокол — односимвольный: один байт — одна команда.

```c
char cmd = getchar();       // получаем один байт от пользователя
if (cmd == 'e') {
    gpio_put(LED_PIN, 1);  // enable — включить
} else if (cmd == 'd') {
    gpio_put(LED_PIN, 0);  // disable — выключить
} else if (cmd == 'b') {
    start_blink();          // blink — мигать
}
```

Работает, но очень ограничено: 26 букв латинского алфавита — и команды закончились. Нельзя передать параметр (с каким периодом мигать?), нельзя добавить подсказку. Протокол можно усложнить — перейти от одного символа к текстовым командам, а затем к командам с аргументами:

| Уровень протокола | Пример ввода | Возможности |
|-------------------|-------------|-------------|
| Односимвольный | `e`, `d`, `b` | Одна буква — одно действие |
| Текстовые команды | `help`, `version` | Читаемые имена, легко запомнить |
| Команды с аргументами | `blink 500`, `mem 0x20000000` | Передача параметров: период, адрес |

Чем сложнее протокол, тем больше кода уходит на разбор ввода. И этот код хочется отделить от логики самих команд — включения светодиода, чтения памяти, вывода справки. Именно здесь появляется потребность в API.

## API как слой над протоколом

На Raspberry Pi вы использовали библиотеку `gpiozero` — вызывали `led.on()`, не задумываясь о регистрах и адресах. Набор таких функций, которые скрывают детали реализации и предоставляют удобный интерфейс для программиста, называют **API**.

![[СтруктураПротоколов.drawio.png]]

>[!NOTE] Определение
>**API** (*Application Programming Interface*) — набор функций, скрывающих детали реализации и предоставляющих удобный интерфейс для программиста. API позволяет работать с устройством через вызовы вроде `gpio_put()`, не зная, какие именно регистры и биты стоят за этим.

В Pico SDK это `gpio_put()`, `uart_putc()`, `stdio_init_all()` и сотни других функций. Вы вызываете `gpio_put(LED_PIN, 1)` — не зная, в какой регистр и какие биты пишутся. API скрывает детали общения с периферией.

Вернёмся к нашему протоколу команд. Когда устройство поддерживает много команд, удобно описать каждую команду как структуру: имя, функция-обработчик, описание для подсказки:

```c
typedef struct {
    const char *name;                          // имя команды
    void (*handler)(int argc, char *argv[]);   // функция-обработчик
    const char *description;                   // описание для help
} Command;

Command commands[] = {
    {"help",    cmd_help,    "Вывести список команд"},
    {"version", cmd_version, "Показать версию прошивки"},
    {"blink",   cmd_blink,   "Мигать: blink <период_мс>"},
    {"mem",     cmd_mem,     "Прочитать память: mem <адрес>"},
};
```

Эта таблица и есть API нашего устройства. Обработчик протокола читает строку из терминала, находит команду в таблице и вызывает её обработчик. Обработчик ничего не знает о протоколе — он получает уже разобранные аргументы. Протокол ничего не знает о светодиодах и памяти — он только разбирает ввод и передаёт управление. Это разделение позволяет менять протокол (например, перейти с текстовых команд на бинарные пакеты), не трогая логику команд, — и наоборот.

И от всего этого многоуровневого кода мы хотим только одного, чтобы наше общение с устройством складывалось по принципу "отправил команду — получил результат".


![[СутьAPI.drawio.png]]

## Архитектура обработки событий

Мы научили контроллер мигать и даже принимать команды. Но попробуйте совместить одно с другим: blink с `sleep_ms(250)` не может одновременно мигать и читать терминал. Пользователь нажимает клавишу — а микроконтроллер в это время ждёт 250 миллисекунд и не обращает на ввод внимания:

```c
while (1) {
    gpio_put(LED_PIN, 1);
    sleep_ms(250);          // 250 мс программа не реагирует ни на что
    gpio_put(LED_PIN, 0);
    sleep_ms(250);          // ещё 250 мс тишины
    // когда проверять ввод? — некогда!
}
```

Линейное выполнение в суперцикле не подходит, когда нужно одновременно реагировать на ввод, вести таймеры и управлять выходами. Как только появляется пользователь и интерфейс, возникает потребность в **архитектуре обработки событий**: не ждать блокирующе, а опрашивать ввод, проверять таймеры и реагировать на происходящее. Это переход от «сделал — подождал — сделал» к «проверил — отреагировал — проверил снова».

В [[Архитектура ВПО|следующем разделе]] мы разберём, как строить такое поведение: задачи, планировщики, машины состояний.


| **[[Время внутри микроконтроллера\|Предыдущий раздел]]** | [[Как начать писать код для микроконтроллера\|К занятию]] | **[[Архитектура ВПО\|Следующий раздел]]** |
| ------------------------------------------------------- | ------------------------------------------------------- | ----------------------------------------- |
