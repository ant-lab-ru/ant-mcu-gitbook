---
тема: Управляемый светодиод
автор: Егор Анатольевич Денисов
дата: 2026-02-11
---

# Результат

- [ ] создана папка с файлами `protocol-task.h` и `protocol-task.c`;
- [ ] `protocol-task.c` добавлен в `CMakeLists.txt`
- [ ] в `protocol-task` созданы функции инициализации и обработчика;
- [ ] `protocol-task.c` написана логика протокола команд;
- [ ] в `main.c` добавлена инициализация и регулярный вызов обработчика `protocol-task`;
- [ ] в `main.c` в протокол добавлена команда `version` и колбэк для этой команды;
- [ ] прошивка скомпилирована и загружена на Pi pico
- [ ] на отправку команды `version` через COM-порт, после нажатия `Enter`, устройство выдает свои имя и версию

# Инструкция

1. создать в проекте папку `protocol-task`. В папке создайте файлы `protocol-task.h` и `protocol-task.c`. Должна получиться следующая структура файлов:

```
02-control
|-- stdio-task
|   |-- stdio-task.h
|   `-- stdio-task.c
|-- protocol-task
|   |-- protocol-task.h
|   `-- protocol-task.c
|-- main.c
|-- CMakeLists.txt
|-- memmap_rp2040.ld
|-- pico_sdk_import.cmake
```

2. в `CMakeLists.txt` добавить в add_executable включение исходных файлов `protocol_task`:

``` cmake
${CMAKE_CURRENT_SOURCE_DIR}/protocol-task/protocol-task.c
```

3. в файл `protocol-task.h` добавить директиву препроцессора для предотвращения многократного включения заголовочного файла
4. в файл `protocol-task.h` добавить объявление типа `command_callback_t`, являющего указателем на функцию:

``` c
typedef void(*command_callback_t)(const char* args);
```

5. в файл `protocol-task.h` добавить объявление типа структуры команды, состоящего из имени команды, колбэка команды, описания команды:

``` c
typedef struct
{
	const char* command_name;
	command_callback_t command_callback;
	const char* command_help;
} api_t;
```

6. в файл `protocol-task.h` добавить объявление прототипа функции инициализации, принимающей аргументом указатель на массив команд:

``` c
void protocol_task_init(api_t* device_api);
```

7. в файл `protocol-task.h` добавить объявление прототипа функции обработчика, принимающей аргументом строку с командой:

``` c
void protocol_task_handle(char* command_string);
```

---

8. в файл `protocol-task.c` добавить заголовочный файл `protocol-task.h`;
9. в файл `protocol-task.c` добавить заголовочный файл стандартной библиотеки ввода-вывода;
10. в файл `protocol-task.c` добавить заголовочный файл стандартной библиотеки работы со строками `string.h`;
11. в файл `protocol-task.c` добавить переменные для хранения указателя на массив команд и его размер:

``` c
static api_t* api = {0};
static int commands_count = 0;
```

12. в файл `protocol-task.c` добавить реализацию функции инициализации. Функция должна сохранить указатель на массив комманд в переменную `api`, подсчитать число команд и сохранить его в переменную `commands_count`;

> [!ATTENTION] Подсказка
> В массиве команд, после последней команды будет расположен элемент с нулевым значением вместо имени команды. По нему можно понять, что вы дошли до конца массива команд. 

13. в файл `protocol-task.c` добавить реализацию функции обработчика. Ниже представлен шаблон функции обработчика, который требуется заполнить
``` c
void protocol_task_handle(char* command_string)

{

//	Добавляем в обработчик проверку на то, что `command_string` не равно `NULL`.
//	Если `command_string` равно `NULL`, то выйти из обработчика: строка команды
//	еще не получена;
    if (!command_string)
    {
        // ваш код
    }

// логика обработки полученной строки. Делим ее на команду и аргументы:
    const char* command_name = command_string;
    const char* command_args = NULL;

    char* space_symbol = strchr(command_string, ' ');

    if (space_symbol)
    {
        *space_symbol = '\0';
        command_args = space_symbol + 1;
    }
    else
    {
        command_args = "";
    }

  
// Добавляем вывод найденных имени команды и ее аргументов;
    // ваш код

  
// в цикле проходим по массиву команд `api` и ищем совпадение имени команды;

    for (int i = 0; i < ???; i++)
    {
    // определяем совпадает ли команда  с именем команды в массиве `api`
    // если не совпадает, переходим к следующей итерации
            
    // ваш код
            
    // мы нашли команду, вызываем callback найденной команды
        api[i].command_callback(command_args);
        return;
    }
    // выводим ошибку, если команда не была найдена в списке команд
    // ваш код
    return;
}
```


> [!ATTENTION] Подсказка
> Для сравнения строк предлагается использовать функцию `strcmp()`. Она возвращает 0, если строки равны.
> Пример ее использования: `strcmp(command_name, api[i].command_name)`



---

14. в `main.c` добавить включение заголовочного файла модуля `protocol-task`:

``` c
#include "protocol-task/protocol-task.h"
```

15. в `main.c` создать функцию с именем `version_callback` для вывода версии устройства:

``` c
void version_callback(const char* args)
{
	printf("device name: '%s', firmware version: %s\n", DEVICE_NAME, DEVICE_VRSN);
}
```

16. в `main.c` создать массив команд с одной командой `version`, указателем на колбэк этой команды и с описанием:

``` c
api_t device_api[] =
{
	{"version", version_callback, "get device name and firmware version"},
	{NULL, NULL, NULL},
};
```

> [!ATTENTION] Внимание!
> Последним элементом массива должна быть нулевая структура. Это наша договоренность, чтобы легко определять длину массива.

17. добавить в `main.c` инициализацию `protocol-task`. Передать аргументом структуру `device_api`;
18. добавить в `main.c` вызов обработчика `protocol-task`. Передать аргументом строку, считанную `stdio_task_handle()`;
19. скомпилировать прошивку, загрузить в RP2040, проверить работоспособность. На отправленную команду `version` в COM-порт, RP2040 должен возвращать имя устройства и версию прошивки.