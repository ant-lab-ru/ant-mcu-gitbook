---
тема: Мигающий светодиод
автор: Григорьев Василий
дата: 2026-02-04
---

# Результат

- [ ] На вашем компьютере установлен и настроен терминал (`PUTTY` для Windows, `screen` для Linux/MacOS);
- [ ] Создан новый проект прошивки с названием `02-printf`;
- [ ] В проекте прошивки stdio настроен на работу через USB CDC;
- [ ] При запуске прошивки в терминале PUTTY выводятся `Hello World!`, имя устройства, версия и строки с примерами вывода разных переменных:

![[Pasted image 20260211171206.png]]
# Установка и настройка программы для работы с COM-портом

1. Установите программу для работы с COM-портом [[Установка и настройка программы работы с COM-портом]]

# Создание нового проекта

1. Создать проект с названием `02-printf` аналогично [[Как начать работать с микроконтроллерами]].

> [!ATTENTION] Внимание!
> Вы можете скопировать папку проекта из предыдущего занятия и поменять ее название.

2. Проверить, что у вас получилась следующая структура папок:

```
mcu
|-- 02-printf
	|-- main.c
	|-- CMakeLists.txt
	|-- linker_rp2040.ld
    |-- pico_sdk_import.cmake
```

3. Поменять название проекта в `CMakeLists.txt` с `01-blink` на `02-printf`. Строчка создания проекта должна выглядеть вот так:

``` cmake
project(02_printf)
```

4. Заменить везде в остальных пестах имя проекта на переменную `${PROJECT_NAME}`, чтобы в дальнейшем менять имя только в строке `project`, а не во всем `CMakeLists.txt` файле. Например, добавление в проект файлов с исходным кодом теперь будет выглядеть так:

``` cmake
add_executable(${PROJECT_NAME}
    ${CMAKE_CURRENT_SOURCE_DIR}/main.c
)
```

# Настройка stdio на работу через USB CDC

1. Добавить в `CMakeLists.txt` настройки вывода stdio в интерфейс USB после строки с назначением `linker script`:

``` cmake
pico_enable_stdio_uart(${PROJECT_NAME} 0)
pico_enable_stdio_usb(${PROJECT_NAME} 1)
```

> [!ATTENTION] Внимание!
> 
> RP2040 посредством Pico-SDK умеет направлять стандартный поток ввода-вывода либо в UART, либо в USB. Мы будем работать с микроконтроллером через USB, через виртуальный COM-порт (VCP).

# Создание прошивки

> [!ATTENTION] Внимание!
> Если Вы создавали проект копированием файлов с прошлого занятия, то Вам нужно очистить ```main.c```

1. Подключить заголовочные файлы трех библиотек:
	- заголовочный файл стандартной библиотеки ввода вывода (stdio): `stdio.h`
	- заголовочный файл стандартной библиотеки: `stdlib.h`
	- заголовочный файл базового взаимодействия с микрокнтроллером: `pico/stdlib.h`

2. Задать макросы с именем устройства и версией прошивки:

``` c
#define DEVICE_NAME "my-pico-device"
#define DEVICE_VRSN "v0.0.1"
```

3. Создать до функции `main()` глобальную переменную и глобальную постоянную:

``` c
uint32_t global_variable = 0;

const uint32_t constant_variable = 42;
```

4. В теле `main()` инициализировать систему ввода/вывода `stdio` следующей строчкой:

``` c
stdio_init_all();
```

4. В тело бесконечного цикла добавить вывод просто строковой константы:

``` c
printf("Hello World!\n");
```

5. В тело бесконечного цикла добавить вывод строки с аргументами:

``` c
printf("device name: '%s', firmware version: %s\n", DEVICE_NAME, DEVICE_VRSN);
```

6. В теле бесконечного цикла считать счетчик микросекунд и вывести его значение:

``` c
uint64_t timestamp = time_us_64();
printf("system timestamp: %llu us\n", timestamp);
```

7. В теле бесконечного цикла создать переменную на стеке и вывести ее адрес и значение в разных форматах:

``` c
uint32_t stack_variable = 8888;
printf("stack variable | addr = 0x%X | value = %u\n", &stack_variable, *(&stack_variable));
printf("stack variable | addr = 0x%X | value = %X\n", &stack_variable, *(&stack_variable));
printf("stack variable | addr = 0x%X | value = 0x%X\n", &stack_variable, *(&stack_variable));
```

8. В теле бесконечного цикла инкрементировать значение глобальной переменной и вывести ее значение и адрес:

``` c
global_variable++;
printf("global variable | addr = 0x%X | value = %u\n", &global_variable, *(&global_variable));
```

9. В теле бесконечного цикла создать переменную на куче, записать в нее значение и вывести ее значение и адрес:

``` c
uint32_t* heap_variable = (uint32_t*)malloc(sizeof(uint32_t));
*heap_variable = 5555;
printf("heap variable | addr = 0x%X | value = %u\n", heap_variable, *heap_variable);
```

  > [!ATTENTION] Внимание!
> Здесь специально допущена ошибка: после `malloc` не вызывается `free`. За счет этого каждый цикл выделяется новая память для переменной `heap_variable` и мы можем видеть как растет ее адрес. Из-за этой ошибки в какой-то момент закончится память и прошивка упадет либо будет stack overflow.

10. В тело бесконечного цикла добавить вывод адреса и значения постоянной:

 ``` c
 printf("constant variable | addr = 0x%X | value = %u\n", &constant_variable, *(&constant_variable));
 ```

11. В теле бесконечного цикла добавить вывод адреса и значения строковой постоянной:

``` c
printf("constant string | addr = 0x%X | value = 0x%X, [%s]\n", DEVICE_NAME, *((uint32_t*)DEVICE_NAME), DEVICE_NAME);
```

12. В теле бесконечного цикла добавить вывод адреса и значения одного из множества регистров RP2040 с обращением прямо по адресу:

``` c
printf("reg chip id | addr = 0x%X | value = 0x%X\n", 0x40000000, *((uint32_t*)0x40000000));
```

13. В теле бесконечного цикла добавить вывод адреса и значения `global_variable` с обращением прямо по адресу:

``` c
printf("var by addr | addr = 0x%X | value = %u\n", 0x20002278, *((uint32_t*)0x20002278));
```

14. В теле бесконечного цикла добавить вывод адреса функции `main` и первых бинарных команд этой функции:

``` c
printf("main function | addr = 0x%X | value = 0x%X\n", main, *((uint32_t*)main));
```

15. Добавить задержку в тело бесконечного цикла:

``` c
sleep_ms(1000);
```

16. Собрать прошивку, загрузить в устройство, запустить и считать вывод через терминал.

17. Убедиться, что адреса переменных соответствуют ожидаемым, т.е. определите какие адреса располагаются во FLASH, а какие в SRAM. Для этого обратитесь к схеме секций памяти в [[Память в ВПО|статье]].

