---
тема: Управляемый светодиод
автор: Егор Анатольевич Денисов
дата: 2026-02-11
---

# Результат

- [ ] создана папка с файлами `led-task.h` и `led-task.c`;
- [ ] `led-task.c` добавлен в `CMakeLists.txt`
- [ ] в `led-task` созданы функции инициализации и обработчика;
- [ ] в `led-task` написана неблокирующая машина состояний для светодиода с тремя состояниями:
	- выключен;
	- включен;
	- мигает;
- [ ] в `stdio-task` создана функция смены состояния;
- [ ] в `led-task` написана машина состояний для светодиода;
- [ ] в `main.c` добавлена инициализация и регулярный вызов обработчика `led-task`;
- [ ] в `main.c` в протокол добавлены команды и колбэки:
	- `on`;
	- `off`;
	- `blink`;
- [ ] прошивка скомпилирована и загружена на Pi pico;
- [ ] на отправку команды `on`, `off`, `blink` и `version` через COM-порт, после нажатия `Enter`, устройство выполняет эти команды

# Инструкция

1. создать в проекте модуль `led-task`. Должна получиться следующая структура файлов:

```
02-control
|-- stdio-task
|   |-- stdio-task.h
|   `-- stdio-task.c
|-- protocol-task
|   |-- protocol-task.h
|   `-- protocol-task.c
|-- led-task
|   |-- led-task.h
|   `-- led-task.c
|-- main.c
|-- CMakeLists.txt
|-- memmap_rp2040.ld
|-- pico_sdk_import.cmake
```

2. в `CMakeLists.txt` добавить в add_executable включение исходных файлов `led_task`;

3. в файл `led-task.h` добавить директиву препроцессора для предотвращения многократного включения заголовочного файла;

4. в файл `led-task.h` добавить объявление типа перечисления `led_state_t`  с набором из трех возможных состояний светодиода:

``` c
typedef enum
{
	LED_STATE_OFF = 0,
	LED_STATE_ON = 1,
	LED_STATE_BLINK = 2,
} led_state_t;
```

6. в файл `led-task.h` добавить объявление прототипов функций инициализации без аргументов и обработчика без аргументов;

7. в файл `led-task.h` добавить объявление прототипов функций изменения состояния светодиода:

``` c
void led_task_state_set(led_state_t state);
```

---

8. создать шапку `led-task.c` файла c необходимыми переменными:

``` c
#include "led-task.h"

#include "pico/stdlib.h"
#include "hardware/gpio.h"

const uint LED_PIN = 25;
uint LED_BLINK_PERIOD_US = 500000;

uint64_t led_ts;
led_state_t led_state;
```

9. создать функцию инициализации, она должна:
	- задать состояние светодиода OFF
	- задать метку времени `led_ts` как ноль
	- проинициализировать светодиод

10. создать функцию обработчика. В зависимости от состояния она должна:
	- включать светодиод
	- выключать светодиод
	- неблокирующе мигать светодиодом

> [!ATTENTION] Подсказка
> Предлагаем использовать switch в обработчике:
> ``` c
> switch (led_state)
>{
>case LED_STATE_OFF:
>	// ваш код
>	break;
>case LED_STATE_ON:
>	// ваш код
>	break;
>case LED_STATE_BLINK:
>	// ваш код
>	break;
>default:
>	break;
>}
> ```

> [!ATTENTION] Подсказка
> Чтобы реализовать неблокирующее мигание, вам придется сохранять метку времени и использовать время микроконтроллера. Пример логики регулярного неблокирующего вызова: 
> ``` c
> if (time_us_64() > led_ts)
>{
>	led_ts = time_us_64() + (LED_BLINK_PERIOD_US / 2);
>	// ваш код
>}
> ```

11. создать функцию установки состояния, она должна:
	- установить состояние передаваемое в функцию в ```led_state```
---

12. в `main.c` включить заголовочный файл `led-task`
13. в `main.c` добавить инициализацию и обработчик `led-task`
14. в `main.c` добавить функции колбэков:
	- `led_on_callback`
	- `led_off_callback`
	- `led_blink_callback`
15. в `main.c` в `device_api` добавить команды с описаниями и колбэками:
	- on
	- off
	- blink

16. скомпилировать прошивку, загрузить в RP2040, проверить работоспособность. На отправленную команду `version` в COM-порт, RP2040 должен возвращать имя устройства и версию прошивки. На команды `on` и `off` включать и выключать светодиод. На `blink` светодиод должен начать мигать.


