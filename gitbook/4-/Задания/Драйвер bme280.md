---
тема: Как работать с внешней периферией
автор: Егор Анатольевич Денисов
дата: 2026-02-25
---

# Результат

- [ ] создан пустой драйвер `bme280`
- [ ] в драйвере создана структура контекста
- [ ] в драйвере написана функция инициализации, инициализирующая контекст драйвера
- [ ] в драйвере написана функция чтения регистра bme280
- [ ] в API устройства добавлена команда `read_reg addr N`, читающая N регистров bme280 начиная с указанного адреса
- [ ] в прошивке инициализируется I2C
- [ ] написаны функции чтения и записи I2C
- [ ] датчик BME280 подключен к pi pico
- [ ] проект собран, запущен, при чтении регистра `id` возвращается значение `0x60`

![[Pasted image 20260225173403.png]]

# Инструкция

1. По аналогии с `protocol` создать библиотеку `bme280-driver` в папке `libs`. Файлы `bme280-driver.h` и `bme280-driver.c` создать пустыми. `CMakeLists.txt` создать по аналогии с `protocol`, имя проекта библиотеки указать `bme280_driver`. Структура файлов должна получиться следующая:

```
libs
|-- bme280-driver
|   |-- include
|   |   `-- bme280-driver.h
|   |-- src
|   |   `-- bme280-driver.cpp
|   `-- CMakeLists.txt
|-- protocol
|   |-- include
|   |   `-- protocol-task.h
|   |-- src
|   |   `-- protocol-task.cpp
|   `-- CMakeLists.txt
```

2. В начало `bme280-driver.h` добавить директиву препроцессора для предотвращения многократного включения

3. Включить заголовочный файл библиотеки целочисленных типов:

``` c
#include <stdint.h>
```

> [!INFO] Обратите внимание!
> Ранее мы достаточно вольно обращались с типами данных. С этого момента мы начинаем строго контролировать типы, для чего необходима  стандартная библиотека `stdint`

4. Создать типы указателей на функции для чтения и записи данных в I2C шину:

``` c
typedef void (*bme280_i2c_read)(uint8_t* buffer, uint16_t length);
typedef void (*bme280_i2c_write)(uint8_t* data, uint16_t size);
```

5. Создать прототип функции инициализации bme280, принимающий указатели ра функции чтения и записи в I2C:

``` c
void bme280_init(bme280_i2c_read i2c_read, bme280_i2c_write i2c_write);
```

6. Создать прототип функции чтения регистров BME280:

``` c
void bme280_read_regs(uint8_t start_reg_address, uint8_t* buffer, uint8_t length);
```

> [!INFO] Пояснение
> Функция будет читать `[ length ]` регистров  BME280, начиная с адреса `[ start_reg_address ]`. Считанные значения функция записывавает в указатель на буфер `[ buffer ]`. Размер `buffer` обязан быть не менее `length` байт.

7. В файл `bme280-driver.c` добавить включение заголовочного файла библиотеки  `bme280-driver`

8. В файле `bme280-driver.c` создать тип для объединения всех переменных, необходимых для работы драйвера:

``` c
typedef struct
{
	bme280_i2c_read i2c_read;
	bme280_i2c_write i2c_write;
} bme280_ctx_t;
```

9. Создать статическую переменную типа `bme280_ctx_t`:

``` c
static bme280_ctx_t bme280_ctx = {0};
```

> [!INFO] Справка
> Переменные, хранящие состояние библиотеки или других программных модулей принято называть контексом.
> Т.е. `bme280_ctx` - это контекст драйвера BME280

10. В файле `bme280-driver.c` реализовать функцию `bme280_init`. Она должна сохранить переданные указатели на функции в контекст.

11. В файле `bme280-driver.c` реализовать функцию чтения регистров BME280 согласно пункту 6.2.2 на стр. 31 [[BME280 Datasheet.pdf|документации BME280]] . Для этого в функции чтения регистров надо:
	- создать массив `uint8_t` длиной 1, содержащий адрес регистра, с которого должно начаться чтение

	``` c
	uint8_t data[1] = {start_reg_address};
	```

	- отправить на шину I2C адрес регистра, с которого мы хотим начать чтение:

	``` c
	bme280_ctx.i2c_write(data, sizeof(data));
	```

	- прочитать по I2C шине желаемое количество регистров сразу в буффер пользователя:

	``` c
	bme280_ctx.i2c_read(buffer, length);
	```

13. Подключить библиотеку `bme280_driver` в проект `04-bme`

> [!INFO] Напоминание
> Для этого в CMakeLists.txt надо добавить `add_subdirectory` и добавить библиотеку в `target_link_libraries`

14. В API устройства добавить команду `read_reg` с двумя аргументами. Первый - адрес, с которого нужно начать читать регистры BME280. Второй - сколько регистров надо прочитать. Оба значния не могу превышать 0xFF, т.к. в BME280 8-битные адреса и регистры.

> [!INFO] Подсказка
> В реализации read_regs_callback можно всегда создавать буфер длиной 256 байт, т.к. этого гарантированно хватит для чтения всех регистров:
> ``` c
> uint8_t buffer[256] = {0};
> bme280_read_regs(addr, buffer, N);
> ```

15. Убедитесь, что вы добавили проверки:
	- addr <= 0xFF
	- N <= 0xFF
	- addr + N <= 0x100

16. Убедитесь, что вы сделали красивый вывод значений регистров BME280 на подобии такого:

``` c
for (int i = 0; i < N; i++)
{
	printf("bme280 register [0x%X] = 0x%X\n", addr + i, buffer[i]);
}
```

17. Подключить библиотеку `hardware_i2c` в проект `04_bme`

18. В `main.c` подключить заголовочный файл библиотеки i2c:

``` c
#include "hardware/i2c.h"
```

19. Создать функцию чтения из I2C шины

``` c
void rp2040_i2c_read(uint8_t* buffer, uint16_t length)
{
	i2c_read_timeout_us(i2c1, 0x76, buffer, length, false, 100000);
}
```

20. Создать функцию записи в I2C шину

``` c
void rp2040_i2c_write(uint8_t* data, uint16_t size)
{
	i2c_write_timeout_us(i2c1, 0x76, data, size, false, 100000);
}
```

> [!INFO] Справка
> Идея использования в драйвере указателей на функции вместо прямого вызова i2c_read_timeout_us состоит в том, что драйвер остается платформонезависимым и может использоваться на любом микроконтроллере и даже компьютере. Более того, драйвер упрощается, т.к. не должен учитывать особенности работы под конкретную платформу.

21. В `main.c` добавить инициализацию i2c1 на частоту 100кГц:

``` c
i2c_init(i2c1, 100000);
```

22. В `main.c` добавить настройку функций ножек GP14 и GP15 на I2C:

``` c
gpio_set_function(14, GPIO_FUNC_I2C);
gpio_set_function(15, GPIO_FUNC_I2C);
```

23. В `main.c` добавить инициализацию драйвера bme280

24. Физически подключить плату BME280 к Pi pico:

```
BME280 VIN - PICO VBUS
BME280 GND - PICO GND
BME280 SCL - PICO GP15
BME280 SDA - PICO GP14
```

25. скомпилировать прошивку, загрузить в RP2040, проверить работоспособность. На вызов команды `read_regs d0 1`, RP2040 должен возвращать в COM-порт считанное из BME280 значение регистра по адресу `0xD0`.  Считанное значение должно быть равно `0x60`.
