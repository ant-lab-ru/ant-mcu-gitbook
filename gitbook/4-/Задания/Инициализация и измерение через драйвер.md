---
тема: Как работать с внешней периферией
автор: Егор Анатольевич Денисов
дата: 2026-02-25
---

# Результат

- [ ] в драйвере BME280 создан файл `bme280-regs.h` с картой регистров BME280
- [ ] функция инициализации драйвера читает и проверяет ID BME280
- [ ] функция инициализации драйвера записывает в BME280 следующие настройки:
	- [ ] в регистр BME280 `ctrl_hum` вписать:
		- оверсэмплинг измерения влажности `Humidity oversampling` = 1 
	- [ ] в регистр BME280 `config` вписать:
		- задержку между измерениями `t_standby` = 62.5 мс
		- IIR фильтр выключен
		- `spi3w_en` = 0
	- [ ] в регистр BME280 `ctrl_meas` вписать:
		- оверсэмплинг измерения давления `Pressure oversampling` = 1 
		- оверсэмплинг измерения температуры `Temperature oversampling` = 1 
		- режим BME280 = Normal mode
- [ ] в API устройства добавлены функции чтения показаний температуры, давления и влажности **в отсчетах** (`temp_raw`, `pres_raw`, `hum_raw`)
- [ ] проект собран, запущен, команды `temp_raw`, `pres_raw`, `hum_raw` выдают значения

# Инструкция

1. Создать файл `bme280-regs.h` в папке `bme280-driver/include`

2. В файле создать карту регистров BME280. Названия и адреса регистров можно посмотреть в [[BME280 Datasheet.pdf|документации BME280]] (таблица 18 на стр. 25). Пример представлен ниже, аналогично надо создать константы для остальных адресов.

``` c
#define BME280_REG_id 0xD0
```

> [!INFO] Совет
> Из PDF файла документации можно копировать: переписывать все адреса и название вручную не нужно

4. в файл `bme280-driver.c` добавить включение заголовочного файла `bme280-regs.h`

5. в файл `bme280-driver.c`, в функцию инициализации драйвера добавить чтение регистра ID BME280 и проверить, что ID = 0x60. Если не равен, вывести сообщение:

``` c
uint8_t id_reg_buf[1] = {0};
bme280_read_regs(BME280_REG_id, id_reg_buf, sizeof(id_reg_buf));

// ваш код с проверкой считанного значения
```

5. в файл `bme280-driver.c`, в функцию инициализации драйвера добавить запись в регистр `ctrl_hum` (таблица 19 стр. 26 [[BME280 Datasheet.pdf|документации BME280]]) следующих настроек:
	- оверсэмплинг измерения влажности `Humidity oversampling` = 1 

``` c
uint8_t ctrl_hum_reg_value = 0;
ctrl_hum_reg_value |= (0b001 << 0); // osrs_h[2:0] = oversampling 1
bme280_write_reg(BME280_REG_ctrl_hum, ctrl_hum_reg_value);
```

> [!INFO] Что произошло?
> Из документации BME280 мы видим, что в регистре `ctrl_hum` всего одно значащее поле под названием `osrs_h`, задающее параметры измерения влажности. По умолчанию измерение влажности выключено (Skipped). Нам нужно его включить, оверсэмплинг нам не нужен, поэтому мы вписываем значение 0b001, согласно таблице 20. Значение нужно сдвинуть на положение поля `osrs_h` внутри регистра. Тут это ноль, поэтому сдвиг на 0 бит. Битовый сдвиг на 0 можно не делать, но для единообразия его принято писать.

6. в файл `bme280-driver.c`, в функцию инициализации драйвера добавить запись в регистр BME280 `config` (таблица 26 стр. 28 [[BME280 Datasheet.pdf|документации BME280]]) следующих настроек:
	- `spi3w_en` = 0
	- IIR фильтр выключен
	- задержку между измерениями `t_standby` = 62.5 мс

``` c
uint8_t config_reg_value = 0;
config_reg_value |= (0b0 << 0); // spi3w_en[0:0] = false
config_reg_value |= (0b000 << 2); // filter[4:2] = Filter off
config_reg_value |= (0b001 << 5); // t_sb[7:5] = 62.5 ms
bme280_write_reg(BME280_REG_config, config_reg_value);
```

7. в файл `bme280-driver.c`, в функцию инициализации драйвера добавить запись в регистр BME280 `ctrl_meas` (таблица 22 стр. 27 [[BME280 Datasheet.pdf|документации BME280]]) следующих настроек:
	- режим BME280 = Normal mode
	- оверсэмплинг измерения температуры `Temperature oversampling` = 1 
	- оверсэмплинг измерения давления `Pressure oversampling` = 1 

8. Реальзовать в драйвере BME280 функции чтения значений температуры, даавления и влажности в отсчетах. Покажем на примере температуры, остальное реализовать самостоятельно:

``` c 
// bme280-driver.h
uint16_t bme280_read_temp_raw();

// bme280-driver.c
uint16_t bme280_read_temp_raw()
{
	uint8_t read[2] = {0};
	bme280_read_regs(BME280_REG_temp_lsb, read, sizeof(read));
	uint16_t value = ((uint16_t)read[1] << 8) | ((uint16_t)read[0]);
	return value;
}
```

> [!INFO] Что произошло?
> Результаты измерений BME280 имеют размер 16 бит. Регистры BME280 всего 8 бит. Поэтому, для чтения измерения нам необходимо считать две регитра: младшую часть значения (lsb) и старшую часть значения (msb). Обязательно нужно их считать за один вызов `bme280_read_regs`. Считанные два числа надо объединить в одно 16-битное.

9. В API устройства добавить команды `temp_raw`, `pres_raw`, `hum_raw`, возвращающие значения измерения в отсчетах

10. скомпилировать прошивку, загрузить в RP2040, проверить работоспособность. Значения `temp_raw`, `pres_raw`, `hum_raw` должны изменяться и быть разными 
