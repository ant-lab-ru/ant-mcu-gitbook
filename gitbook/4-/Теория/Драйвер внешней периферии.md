---
занятие:
  - "[[Как работать с внешней периферией]]"
дата: 2026-02-25
tags:
  - занятие4
  - теория
---

Мы разобрались, какие интерфейсы существуют и как они работают на физическом уровне. Но когда мы подключаем конкретный датчик — например, BME280 для измерения температуры и давления — как с ним общаться? Откуда взять код для работы с ним? И что вообще означает слово «драйвер» — ведь вы наверняка слышали его в разных контекстах?

## Три значения слова «драйвер»

Слово «драйвер» происходит от английского *to drive* — управлять, приводить в действие. Во встраиваемых системах оно используется минимум в трёх разных смыслах. Чтобы не путаться, разберём каждый.

*Во-первых*, в прошлой статье мы столкнулись с термином трансивер, который иногда называют **драйвером шины** (*англ. bus driver*). Это электронный компонент, а не программа. Микросхема-драйвер управляет напряжением на шине по правилам, заданным стандартом интерфейса.

*Во-вторых*, из опыта работы с компьютерами вы наверняка слышали слово драйвер в смысле «драйвер какого-то устройства». Это **программный модуль в операционной системе**, обеспечивающий связь между ОС и устройством. Драйвер работает в привилегированном режиме и имеет прямой доступ к оборудованию. Например, драйвер принтера имеет полный доступ к USB-порту, к которому подключён принтер, и может обмениваться через него данными с принтером. На Raspberry Pi 4 вы работали с драйверами `spidev` и `smbus` — они позволяли обращаться к SPI и I2C из пользовательского пространства Linux.

*И наконец*, предмет интереса этой статьи — программный драйвер во встраиваемой системе.

>[!NOTE] Определение
>**Программный драйвер** (*англ. device driver library*) — программный модуль, который инкапсулирует детали взаимодействия с устройством и предоставляет набор функций для работы с ним.

В целом, он очень похож на драйвер в ОС. Драйверу предоставляется доступ к некоторому физическому устройству обмена (регистры, SPI, I2C), через которое он может осуществлять обмен данными с другим устройством. Именно этот смысл слова «драйвер» мы будем использовать в этой и следующей статье.

**Общее у всех трёх значений:** драйвер — это то, что «управляет» чем-то другим через некоторый физический интерфейс. В целом, в этом смысле водитель (*driver*) управляет автомобилем через руль, следуя протоколам (правилам) дорожного движения.

## Драйверы внутренней периферии

Прежде всего нам необходимо определить, какая внутренняя периферия нам понадобится. К счастью, Pico SDK уже содержит готовые функции для работы с внутренней периферией микроконтроллера: GPIO, SPI, I2C, UART, таймерами, АЦП. Функции `spi_init()`, `spi_write_blocking()`, `i2c_read_blocking()` — это и есть драйверы соответствующих модулей RP2040. 

Если вас интересует, через какой физический интерфейс они управляют периферией, то этот интерфейс — системная шина памяти. В драйверах SDK содержится полная информация об адресах регистров и устройстве всего микроконтроллера.

### Функции SPI в Pico SDK

| Функция | Описание |
|---------|----------|
| `spi_init(spi, baudrate)` | Инициализирует модуль SPI с заданной скоростью (в Гц). Возвращает фактическую установленную скорость. |
| `spi_write_blocking(spi, src, len)` | Отправляет `len` байт из буфера `src`. Блокирует выполнение до завершения передачи. |
| `spi_read_blocking(spi, repeated_tx, dst, len)` | Читает `len` байт в буфер `dst`. При чтении отправляет байт `repeated_tx` (обычно 0x00). |
| `spi_write_read_blocking(spi, src, dst, len)` | Одновременно отправляет из `src` и принимает в `dst` по `len` байт (полный дуплекс). |

Параметр `spi` указывает, какой из двух модулей SPI использовать: `spi0` или `spi1`. Перед использованием SPI необходимо также назначить пины с помощью `gpio_set_function()`.

```c
spi_init(spi0, 1000000);              // SPI0, скорость 1 МГц
gpio_set_function(16, GPIO_FUNC_SPI); // GP16 → MISO
gpio_set_function(18, GPIO_FUNC_SPI); // GP18 → SCK
gpio_set_function(19, GPIO_FUNC_SPI); // GP19 → MOSI

uint8_t tx_buf[] = {0x01, 0x02};
uint8_t rx_buf[2];
spi_write_read_blocking(spi0, tx_buf, rx_buf, 2);
```

### Функции I2C в Pico SDK

| Функция | Описание |
|---------|----------|
| `i2c_init(i2c, baudrate)` | Инициализирует модуль I2C с заданной скоростью (в Гц). Типичные значения: 100000 (стандартный режим), 400000 (быстрый режим). |
| `i2c_write_blocking(i2c, addr, src, len, nostop)` | Отправляет `len` байт на устройство с адресом `addr`. Если `nostop = true`, не отправляет STOP-условие (для повторного старта). |
| `i2c_read_blocking(i2c, addr, dst, len, nostop)` | Читает `len` байт с устройства по адресу `addr` в буфер `dst`. |

Параметр `i2c` указывает модуль: `i2c0` или `i2c1`. Адрес `addr` — 7-битный адрес устройства.

```c
i2c_init(i2c0, 400000);               // I2C0, скорость 400 кГц
gpio_set_function(4, GPIO_FUNC_I2C);  // GP4 → SDA
gpio_set_function(5, GPIO_FUNC_I2C);  // GP5 → SCL
gpio_pull_up(4);                      // Подтяжка SDA
gpio_pull_up(5);                      // Подтяжка SCL

uint8_t reg = 0xD0;                   // Адрес регистра
uint8_t data;
i2c_write_blocking(i2c0, 0x76, &reg, 1, true);   // Записываем адрес регистра
i2c_read_blocking(i2c0, 0x76, &data, 1, false);  // Читаем значение
```

В примере выше мы читаем регистр `0xD0` с устройства по адресу `0x76`. Параметр `nostop = true` при записи означает, что после передачи адреса регистра шина не освобождается — сразу следует повторный старт и чтение.

## Драйверы внешней периферии

Для конкретного датчика — BME280, MPU6050, дисплея ILI9341 — в SDK нет кода. И это логично: производителей датчиков тысячи, SDK не может включать драйверы для каждого.

Когда вам нужно работать с внешним устройством, есть три пути:

*Во-первых*, **взять готовую библиотеку**. Для популярных датчиков существуют готовые драйверы — на GitHub, на сайте производителя, в сообществе. Часто достаточно скачать и подключить.

*Во-вторых*, **адаптировать существующую библиотеку**. Иногда драйвер написан для другой платформы (Arduino, STM32) и требует портирования. Об этом поговорим далее.

*И наконец*, **написать драйвер с нуля** по даташиту устройства. Для редких или новых устройств это единственный путь.

В драйвере внешней периферии, подобно драйверу внутренней, должна содержаться информация о всех регистрах, параметрах и логике работы устройства. Всё это скрывается от пользователя драйвера за конкретными функциями инициализации, чтения, записи и управления устройством.

>[!NOTE] Из практики
>Для популярных датчиков (BME280, MPU6050, SSD1306) существуют десятки готовых библиотек. Но для редких или новых устройств драйвер придётся писать самостоятельно. Умение читать даташит и создавать драйвер — важный навык инженера встраиваемых систем.

## Платформозависимый и платформонезависимый код

Представьте: вы написали драйвер датчика для RP2040, он работает, проект сдан. Но через полгода наступает кризис полупроводников, RP2040 нет в продаже, и вы решаете поменять микроконтроллер в устройстве. Придётся переписывать весь драйвер?

Ответ зависит от того, как был написан код. Код становится привязанным к платформе, когда использует:
- Функции конкретного SDK: `spi_write_blocking()` в Pico SDK, `HAL_SPI_Transmit()` в STM32
- Специфичные типы данных и макросы
- Прямую работу с регистрами микроконтроллера

Такой код работает только на той платформе, для которой написан. При переносе на другой микроконтроллер его придётся переписывать.

Код, который не зависит от конкретного микроконтроллера, называют **платформонезависимым**. Он работает через абстрактный программный интерфейс и может быть скомпилирован для разных платформ без изменений.

>[!NOTE] Определение
>**Платформозависимый код** (*англ. platform-dependent*) — код, использующий функции конкретного SDK или микроконтроллера. При смене платформы требует переписывания.
>
>**Платформонезависимый код** (*англ. platform-independent*) — код, не привязанный к конкретной платформе. Переносится между микроконтроллерами без изменений.

Из описанного выше следует, что драйверы в SDK являются платформозависимыми. Как же написать код, который не зависит от платформы, но при этом работает с аппаратурой? Для этого используют модульный подход.

## Логика и платформа

Идея проста: разделить драйвер на две части.

**Логика устройства** (платформонезависимая):
- Протокол: какие регистры читать и писать, в какой последовательности
- Вычисления: как преобразовать сырые данные в физические величины
- Состояние: инициализация, режимы работы, обработка ошибок

**Аппаратный интерфейс** (платформозависимая):
- Функции чтения и записи через SPI или I2C
- Управление пинами (CS, reset)
- Задержки

```
┌─────────────────────────────────────────────────────────┐
│         Логика устройства (платформонезависимая)        │
│  • Протокол: какие регистры читать/писать              │
│  • Вычисления: как преобразовать сырые данные          │
│  • Состояние: инициализация, режимы работы             │
└─────────────────────────┬───────────────────────────────┘
                          │ использует callbacks
                          ▼
┌─────────────────────────────────────────────────────────┐
│       Аппаратный интерфейс (платформозависимый)         │
│  • Функции чтения/записи через SPI или I2C             │
│  • Управление пинами (CS, reset)                       │
│  • Задержки                                            │
└─────────────────────────────────────────────────────────┘
```

Логическая часть драйвера требует для исполнения функций так называемый **контекст**.

>[!NOTE] Определение
**Контекст драйвера** (*англ. driver context*) — структура данных, которая хранит состояние устройства и условия его исполнения: указатели на функции обмена (callbacks), идентификаторы платформы (номер SPI, I2C-адрес). Контекст передаётся при инициализации и используется далее в функциях драйвера.

Конкретная степень абстрагирования зависит от разработчика. Контекст может сохраняться в глобальных переменных самого драйвера во время инициализации или передаваться каждый раз при вызове любых функций драйвера. Например, когда вы делали задачу со светодиодом при инициализации вы передавали ножку пина, к которой подключен светодиода. Даже эта одна переменная по факту была изменяемым контекстом, вы могли очень просто подключить свой светодиод к любой ножке и просто изменить контекст при инициализации, сама логика управления светодиодом не поменялась бы.

Платформонезависимая часть не вызывает функции драйверов внутренней периферии напрямую. Вместо этого она вызывает функцию, которая определена в контексте. Сигнатура функции (передаваемые параметры и возвращаемые значения) обычно определяется логической частью драйвера, а аппаратная часть должна подстроиться под неё. При смене платформы логическая часть остаётся неизменной, и разработчику достаточно лишь переписать платформенную часть драйвера.

>[!NOTE] Из практики
>Многие производители датчиков (Bosch, Texas Instruments, STMicroelectronics) предоставляют официальные драйверы именно в таком виде: платформонезависимое ядро и примеры реализации callbacks для популярных микроконтроллеров. Например, официальный драйвер Bosch BME280 требует реализовать функции чтения и записи регистров — и работает на любой платформе.

## Итог

Мы разобрались, что слово «драйвер» имеет несколько значений: драйвер ОС, аппаратный драйвер (микросхема) и программный драйвер (библиотека). В контексте программирования микроконтроллеров мы говорим о программных драйверах.

Для внутренней периферии (GPIO, SPI, I2C) драйверы предоставляет SDK. Для внешней периферии (датчики, дисплеи, память) драйверы часто приходится искать, адаптировать или писать самостоятельно.

Чтобы драйвер можно было переносить между платформами, его разделяют на платформонезависимую логику и платформозависимый аппаратный интерфейс. Связь между ними осуществляется через callbacks.

В следующей статье применим эти концепции на практике: разберём даташит датчика BME280 и спроектируем структуру драйвера для него.

| **[[Как связаться с внеплатной периферией\|Предыдущий раздел]]** | [[Как работать с внешней периферией\|К занятию]] | **[[Разбираемся с BME280\|Следующий раздел]]** |
| ---------------------------------------------------------------- | ------------------------------------------------ | ---------------------------------------------- |
