---
занятие:
  - "[[Как работать с внешней периферией]]"
дата: 2026-02-26
tags:
  - занятие4
  - теория
---

Мы уже разобрались, [[Как связаться с внеплатной периферией|как связаться с внешней периферией]] через I²C. Теперь применим эти знания к конкретному датчику — **BME280**. Это комбинированный сенсор температуры, влажности и давления, который часто используется в метеостанциях, системах умного дома и носимых устройствах. На его примере мы увидим, как читать даташит внешнего модуля и как превратить описание регистров в работающий код.

>[!ATTENTION] Внимание!
>В этом разделе мы будем читать даташит BME280 — настоятельно рекомендуем открыть его и читать вместе с этой статьёй.

## Что такое BME280

Прежде чем погружаться в регистры, давайте поймём, что это за устройство и зачем оно нужно.

>[!NOTE] Определение
>**BME280** — это цифровой комбинированный датчик производства Bosch Sensortec, измеряющий атмосферное давление, относительную влажность и температуру окружающей среды.

Вы уже работали с внешними АЦП на Raspberry Pi — там вы получали «сырое» аналоговое напряжение и сами преобразовывали его в физическую величину. BME280 устроен иначе: внутри него есть три чувствительных элемента (для давления, влажности и температуры), собственный АЦП, память калибровочных коэффициентов и цифровой интерфейс. Вы не работаете с аналоговым сигналом напрямую — датчик сам оцифровывает измерения и отдаёт их по I²C.

Откроем [[0 Документация/BME280 Datasheet.pdf#page=2|даташит на странице 2]] и посмотрим на ключевые характеристики:

| Параметр | Значение |
| --- | --- |
| Корпус | LGA 2,5 × 2,5 × 0,93 мм |
| Интерфейс | I²C (до 3,4 МГц) |
| Напряжение питания VDD | 1,71–3,6 В |
| Напряжение интерфейса VDDIO | 1,2–3,6 В |
| Потребление в режиме сна | 0,1 мкА |
| Потребление при измерении (1 Гц, все три параметра) | 3,6 мкА |
| Диапазон температур | −40…+85 °C |
| Диапазон давления | 300–1100 гПа |
| Диапазон влажности | 0–100 %RH |

Обратите внимание на сверхнизкое энергопотребление: 3,6 мкА при измерении раз в секунду — это на порядки меньше, чем потребляет светодиод. Именно поэтому BME280 популярен в устройствах с батарейным питанием: часах, фитнес-трекерах, портативных метеостанциях.

>[!NOTE] Из практики
>BME280 часто путают с BMP280 — это «младший брат» без датчика влажности. Внешне они идентичны, но у BMP280 chip_id равен `0x58`, а у BME280 — `0x60`. Если ваш датчик не возвращает влажность — проверьте идентификатор.

## Схема пинов и подключение

![[BME280_Pinout.png]]

[[0 Документация/BME280 Datasheet.pdf#page=38|Откроем страницу 38 даташита]]. Для работы по I²C нам важны следующие выводы:

| Пин | Название | Назначение для I²C |
| --- | --- | --- |
| 1, 7 | GND | Земля |
| 3 | SDI | Линия данных SDA |
| 4 | SCK | Тактовый сигнал SCL |
| 5 | SDO | Младший бит I²C-адреса |
| 6 | VDDIO | Питание интерфейса |
| 8 | VDD | Основное питание |

Пин CSB (выбор микросхемы) должен быть подключён к VDDIO — это переводит датчик в режим I²C.

Пин SDO задаёт младший бит I²C-адреса:

- SDO → GND: адрес **0x76**
- SDO → VDDIO: адрес **0x77**

>[!ATTENTION] Внимание!
>Пин SDO нельзя оставлять «в воздухе» — в этом случае адрес I²C будет неопределён и связь не установится.

На практике для подключения модуля BME280 к Raspberry Pi Pico достаточно четырёх проводов:

| BME280 | Pi Pico | Назначение |
| --- | --- | --- |
| VIN | VBUS (5 В) или 3V3 | Питание |
| GND | GND | Земля |
| SCL | GP15 | Тактовый сигнал I²C |
| SDA | GP14 | Данные I²C |

## Карта регистров

[[0 Документация/BME280 Datasheet.pdf#page=26|Откроем пункт 5.3 Memory map]]. В отличие от внутренней периферии RP2040, где мы обращались к регистрам по абсолютным адресам на системной шине, здесь адреса — это номера регистров внутри датчика, к которым мы обращаемся через I²C.

![[BME280_register_map.png]]

Основные регистры BME280:

| Адрес | Имя | Назначение |
| --- | --- | --- |
| 0x88–0xA1 | calib00–calib25 | Калибровочные коэффициенты (часть 1) |
| 0xD0 | id | Идентификатор чипа (0x60 для BME280) |
| 0xE0 | reset | Программный сброс (запись 0xB6) |
| 0xE1–0xF0 | calib26–calib41 | Калибровочные коэффициенты (часть 2) |
| 0xF2 | ctrl_hum | Управление измерением влажности |
| 0xF3 | status | Статус датчика |
| 0xF4 | ctrl_meas | Управление измерением давления и температуры |
| 0xF5 | config | Настройка фильтра и периода ожидания |
| 0xF7–0xF9 | press | Данные давления (20 бит) |
| 0xFA–0xFC | temp | Данные температуры (20 бит) |
| 0xFD–0xFE | hum | Данные влажности (16 бит) |

### Регистр id (0xD0) — проверка связи

Регистр `id` содержит фиксированный идентификатор чипа. [[0 Документация/BME280 Datasheet.pdf#page=27|Страница 27]]. Для BME280 это значение всегда равно **0x60**.

Чтение этого регистра — первое, что нужно сделать после подключения датчика. Если вы получили `0x60` — связь работает, датчик отвечает. Если получили другое значение или ошибку — проверяйте подключение, адрес и питание.

>[!NOTE] Из практики
>Регистр `id` доступен для чтения сразу после подачи питания, даже в режиме сна. Это делает его идеальным для проверки связи: не нужно ничего настраивать, просто читаем один байт.

### Регистр ctrl_meas (0xF4)

Этот регистр — главный «пульт управления» датчиком. [[0 Документация/BME280 Datasheet.pdf#page=28|Откроем страницу 28]].

| Биты | Поле | Назначение |
| --- | --- | --- |
| 7:5 | osrs_t[2:0] | Оверсемплинг температуры |
| 4:2 | osrs_p[2:0] | Оверсемплинг давления |
| 1:0 | mode[1:0] | Режим работы (00 = sleep, 01/10 = forced, 11 = normal) |

**Оверсемплинг** (*oversampling*) — это усреднение нескольких измерений для снижения шума. Чем выше оверсемплинг, тем точнее результат, но дольше измерение и выше потребление.

| Значение osrs_x | Оверсемплинг |
| --- | --- |
| 000 | Пропустить измерение |
| 001 | ×1 |
| 010 | ×2 |
| 011 | ×4 |
| 100 | ×8 |
| 101 и выше | ×16 |

### Регистр ctrl_hum (0xF2)

[[0 Документация/BME280 Datasheet.pdf#page=27|Страница 27]]. Управляет оверсемплингом влажности аналогично температуре и давлению.

>[!ATTENTION] Внимание!
>Изменения в регистре ctrl_hum вступают в силу только после записи в ctrl_meas. Это особенность BME280 — сначала настраиваем влажность, затем пишем в ctrl_meas.

### Регистры данных

Результаты измерений хранятся в регистрах:

- **press** (0xF7–0xF9): 20-битное значение давления
- **temp** (0xFA–0xFC): 20-битное значение температуры
- **hum** (0xFD–0xFE): 16-битное значение влажности

Эти значения — «сырые» показания АЦП. Для получения физических величин нужно применить формулы компенсации с использованием калибровочных коэффициентов.

## Работа с I²C

Теперь самое важное — как именно читать и писать регистры BME280 по шине I²C. [[0 Документация/BME280 Datasheet.pdf#page=32|Откроем страницу 32 даташита]].

![[BME280_I2C_Write.png]]

![[BME280_I2C_Read.png]]

### I²C-адрес

I²C-адрес датчика — 7-битный: `1110 11X`, где X определяется состоянием пина SDO:

- SDO → GND: адрес **0x76** (1110110)
- SDO → VDDIO: адрес **0x77** (1110111)

На большинстве готовых модулей BME280 пин SDO по умолчанию подтянут к GND, поэтому адрес — **0x76**.

### Запись в регистр

Для записи значения в регистр BME280 выполняем стандартную I²C-транзакцию записи:

```
START → адрес устройства + бит записи (W) → адрес регистра → данные → STOP
```

Например, чтобы записать значение `0x27` в регистр `ctrl_meas` (адрес 0xF4):

1. Отправляем START
2. Отправляем адрес устройства `0x76` с битом записи (итого байт `0xEC`)
3. Отправляем адрес регистра `0xF4`
4. Отправляем данные `0x27`
5. Отправляем STOP

### Чтение из регистра

[[0 Документация/BME280 Datasheet.pdf#page=33|Страница 33]]. Чтение выполняется в два этапа:

1. **Сначала записываем адрес регистра**, который хотим прочитать
2. **Затем читаем данные**

```
Этап 1: START → адрес + W → адрес регистра → STOP (или повторный START)
Этап 2: START → адрес + R → читаем данные → STOP
```

На практике это означает два вызова функций I²C: сначала `i2c_write` с одним байтом (адресом регистра), затем `i2c_read` с нужным количеством байт.

>[!NOTE] Из практики
>При чтении нескольких байтов подряд адрес регистра автоматически увеличивается. Поэтому для чтения, например, трёх байт температуры (0xFA, 0xFB, 0xFC) достаточно записать начальный адрес 0xFA и прочитать 3 байта — датчик сам выдаст содержимое всех трёх регистров последовательно.

### Пример: чтение регистра id

Разберём конкретный пример — чтение идентификатора чипа. Регистр `id` находится по адресу **0xD0**.

Последовательность действий:

1. Записываем в I²C адрес регистра: отправляем один байт `0xD0`
2. Читаем из I²C один байт — это и будет значение регистра

В коде с использованием Pico SDK это выглядит так:

```c
uint8_t reg_addr = 0xD0;
uint8_t chip_id;

i2c_write_timeout_us(i2c1, 0x76, &reg_addr, 1, false, 100000);
i2c_read_timeout_us(i2c1, 0x76, &chip_id, 1, false, 100000);
```

Если датчик подключён правильно, в переменной `chip_id` будет значение **0x60**.

>[!ATTENTION] Внимание!
>Всегда читайте данные пакетом (burst read), а не поштучно. Даташит [[0 Документация/BME280 Datasheet.pdf#page=23|на странице 23]] прямо предупреждает: при раздельном чтении регистров можно получить «смесь» байтов из разных измерений.

## Режимы работы

В отличие от внутреннего АЦП микроконтроллера, BME280 имеет три режима работы. [[0 Документация/BME280 Datasheet.pdf#page=14|Откроем страницу 14 даташита]].

![[BME280_State_Machine.png]]

### Режим сна (Sleep mode)

После подачи питания датчик автоматически переходит в **режим сна** (*Sleep mode*). В этом режиме измерения не выполняются, потребление минимально (0,1 мкА), но все регистры доступны для чтения и записи. Здесь мы можем прочитать идентификатор чипа, загрузить калибровочные коэффициенты, настроить параметры измерения.

### Принудительный режим (Forced mode)

**Принудительный режим** (*Forced mode*) — это «одиночный выстрел»: датчик выполняет одно измерение по команде и автоматически возвращается в режим сна. Такой подход похож на то, как мы запускали одиночное преобразование АЦП в RP2040, записывая единицу в бит `START_ONCE`.

Forced mode идеален для приложений с низким потреблением: вы просыпаете микроконтроллер раз в минуту, запускаете измерение, читаете результат и снова засыпаете.

### Нормальный режим (Normal mode)

В **нормальном режиме** (*Normal mode*) датчик автоматически чередует периоды измерения и ожидания. Период ожидания настраивается от 0,5 мс до 1000 мс. Этот режим удобен, когда нужны непрерывные данные.

## Компенсация и калибровка

Каждый экземпляр BME280 имеет индивидуальные калибровочные коэффициенты, записанные на заводе в энергонезависимую память. Коэффициенты хранятся в регистрах 0x88–0xA1 и 0xE1–0xF0.

[[0 Документация/BME280 Datasheet.pdf#page=24|На странице 24]] даташита приведена таблица коэффициентов:

- `dig_T1`, `dig_T2`, `dig_T3` — для температуры (3 коэффициента)
- `dig_P1`…`dig_P9` — для давления (9 коэффициентов)
- `dig_H1`…`dig_H6` — для влажности (6 коэффициентов)

Формулы компенсации приведены в [[0 Документация/BME280 Datasheet.pdf#page=25|разделе 4.2.3]]. Они выглядят громоздко, но логика такая: сначала вычисляется скомпенсированная температура (и попутно — промежуточное значение `t_fine`), затем на основе `t_fine` компенсируются давление и влажность.

## Сравнение с внутренним АЦП RP2040

Полезно сравнить работу с BME280 и со встроенным АЦП микроконтроллера:

| Аспект | АЦП RP2040 | BME280 |
| --- | --- | --- |
| Расположение | Внутри микроконтроллера | Внешняя микросхема |
| Доступ к регистрам | По шине памяти (абсолютные адреса) | По I²C (номера регистров) |
| Проверка связи | Не требуется | Чтение регистра id (0xD0 → 0x60) |
| Калибровка | Не требуется | Обязательна (18 коэффициентов) |
| Режимы | Одиночный / непрерывный | Sleep / Forced / Normal |

Главное отличие: BME280 — это «умный» датчик со своей логикой, памятью и настройками. Мы не управляем отдельными транзисторами, как в случае внутренней периферии, а общаемся с готовым устройством через стандартный протокол.

## Итог

На примере BME280 мы увидели, как устроен типичный цифровой датчик: карта регистров, I²C-протокол чтения и записи, идентификатор для проверки связи. Ключевой момент — чтение регистра: сначала записываем адрес регистра по I²C, затем читаем нужное количество байт. В практическом задании мы напишем драйвер для BME280 и убедимся, что связь работает, прочитав регистр `id`.

| **[[Как связаться с внеплатной периферией\|Предыдущий раздел]]** | [[Как работать с внешней периферией\|К занятию]] | **[[Драйвер bme280\|Следующий раздел]]** |
| ---------------------------------------------------------------- | ------------------------------------------------ | ---------------------------------------- |
