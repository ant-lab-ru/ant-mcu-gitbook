---
занятие:
  - "[[Как работать с внешней периферией]]"
дата: 2026-02-25
tags:
  - занятие4
  - теория
---
Мы разобрались, какие виды периферии существуют. Теперь перед нами встаёт вопрос: каким образом соединить их друг с другом? Подобно API и программным интерфейсам, которые вы использовали при работе с Raspberry Pi, у микроконтроллера и внешней периферии тоже есть свой интерфейс — набор правил обмена данными.

Здесь понятие интерфейса приобретает особое значение. В мире тысячи производителей микросхем, датчиков и устройств, и всем им нужны единые стандарты общения. Очень хорошо, [когда есть единый стандарт](https://xkcd.ru/927/) (наверное).

![[standards_2x.png]]

Во встраиваемых системах ситуация чуть проще: у каждого стандартного интерфейса есть свои сильные и слабые стороны. Важно знать их, когда вы выбираете способ подключения периферии. О них мы и поговорим далее.

## Основные принципы коммуникации

Мы уже с вами разобрали, что такое протоколы и интерфейсы на прошлых занятиях, но в этом занятии мы снова столкнёмся с этими словами в ином контексте, поэтому пришло время поговорить о том, как устроена коммуникация в целом.

Коммуникация — это процесс обмена информацией. Это понятие настолько фундаментальное и общее, что мы даже не будем пытаться дать ему определение. Отметим менее очевидный факт, что процесс коммуникации чаще всего поделен на этапы, в каждом из которых информация преобразовывается из одного вида в другой. Например, когда мы пытаемся что-то сказать другому человеку информация проходит следующие этапы:

- разум генерирует мысль 
- мысль превращается в слова на вашем разговорном языке
- слова представляются как набор звуков из нашего алфавита
- звуки превращаются в движение речевого аппарата
- движения речевого аппарата генерируют распределение давления звуковой волны
- звуковая волна превращается в движение слухового аппарата
- движение слухового аппарата распознаётся как набор звуков алфавита
- звуки алфавита становятся словами на разговорном языке
- слова превращаются в мысль

Из этого примера видно, что хотя на всех этих этапах информацией является мысль, на каждом этапе она преобразуется в другую форму. У каждого этапа есть свои функции и свой набор средств эти функции реализовать. Такие же принципы лежат в основе коммуникации между цифровыми устройствами. В абстрактном виде они описаны в **модели OSI**.

>[!NOTE] Определение
>**Модель OSI** (*англ. Open Systems Interconnection*) — абстрактный набор правил, терминов и концепций, который служит общим базисом для согласованной разработки стандартов в области взаимодействия систем.

По сути, это стандарт, который описывает, по каким правилам должны формироваться стандарты коммуникации. Мы не будем вдаваться в подробности этой модели, возьмём от неё самое важное, а именно разделение процесса коммуникации на уровни.

Подобно примеру, описанному выше, при коммуникации микроконтроллера и периферии изначальная информация проходит несколько этапов, на каждом из которых меняет свою форму, чтобы сообщение дошло до адресата. В общем виде модель OSI содержит семь уровней, но для связи микроконтроллера с периферией на одной плате нам понадобятся только два нижних — физический и канала данных. Остальные уровни актуальны для сетевых протоколов (TCP/IP, HTTP и т.д.), с которыми вы, возможно, столкнётесь позже при работе с WiFi или Ethernet.

| №   | Уровень           | Функция                                      | На какие вопросы отвечает                                   |
| --- | ----------------- | -------------------------------------------- | ----------------------------------------------------------- |
| 1   | **Физический**    | Передача бит по физической среде             | Какие уровни напряжения? Какой разъём? Как кодировать биты? |
| 2   | **Канала данных** | Передача кадров, адресация, обнаружение ошибок | Как идентифицировать устройства? Как обнаружить ошибки?     |
| 3–7 | Сетевой и выше    | Маршрутизация, сессии, шифрование, приложения | *(для сетевого взаимодействия между устройствами)*          |

Каждый из этих уровней имеет свой **интерфейс** и свой **протокол**. В контексте аппаратной коммуникации эти термины означают разные вещи:

- **Интерфейс** — это физическая и электрическая спецификация: какие провода использовать, какие уровни напряжения считать логическим нулём и единицей, какие разъёмы применять. Интерфейс отвечает на вопрос «как физически соединить устройства».

- **Протокол** — это правила обмена данными: в каком порядке передавать биты, как обозначить начало и конец сообщения, как адресовать устройство. Протокол отвечает на вопрос «как договориться о смысле сигналов».

Одни и те же провода (интерфейс) могут использоваться для разных протоколов, и наоборот — один протокол может работать поверх разных физических интерфейсов.

>[!NOTE] Из практики
>Когда вы работали с SPI на Raspberry Pi через библиотеку `spidev`, разделение было таким: пины GPIO и их электрические характеристики — это интерфейс, а последовательность операций `xfer2()` с байтами команд и данных — это протокол общения с конкретной микросхемой (например, АЦП MCP3008).

В устройствах должна быть сущность, которая реализует функции интерфейса. Для физического уровня это аппаратный блок (например, SPI-контроллер в микросхеме), для более высоких уровней — программный код.

Понимание этого разделения поможет вам в следующем разделе, где мы разберём конкретные интерфейсы — SPI, I2C и UART. Для каждого из них мы рассмотрим и физические характеристики (сколько проводов, какие сигналы), и протокольные особенности (как передаются данные, как адресуются устройства).

## Чем интерфейсы отличаются друг от друга

### Последовательная и параллельная передача

Обычно между устройствами информация передаётся порциями по байту. У вас может возникнуть желание проложить восемь проводников от датчика к микроконтроллеру и сразу передавать данные байтами. Таким образом за одну единицу времени мы можем передать сразу 8 бит и увеличить пропускную способность.

>[!NOTE] Определение
>**Пропускная способность** (*англ. throughput*) — количество данных, передаваемых за единицу времени. Измеряется в битах в секунду (бит/с) или байтах в секунду (Б/с).

Увеличение пропускной способности — сильная сторона параллельных интерфейсов. Но есть у них и слабые стороны.

*Во-первых*, увеличение физических размеров. Чем больше проводов, тем больше места им требуется, тем сложнее их разводить. Наглядный пример громоздкости такого подключения — порт LPT (*Line Print Terminal*), уже вышедший из использования.

![[lpt.jpg]]

Таким разъёмом раньше подключались принтеры. Представьте, если бы сейчас для подключения принтера требовался такой огромный разъём — его не поставишь ни на один современный ноутбук. Внутри печатных плат проблемы аналогичны: больше дорожек — сложнее разводка.

*Во-вторых*, это проблемы с синхронизацией битов. Нам нужно понимать, когда все биты параллельного интерфейса находятся в правильном состоянии. Для этого кроме информационных линий добавляется тактовый сигнал, который задаёт моменты времени, в которые все биты должны быть установлены в корректные состояния. Но на высоких скоростях передачи данных мы начинаем ощущать, что сигналы по проводам распространяются не мгновенно, а с конкретной скоростью. Это значит, что длина проводника влияет на время распространения, и если дорожки немного отличаются по длине, сигналы дойдут до микроконтроллера в разные моменты времени. Эта проблема решаема, но требует дополнительного внимания при проектировании.

Последовательная передача устроена иначе. Информация передаётся бит за битом по одной линии. Поскольку синхронизировать нужно только одну линию данных, мы можем увеличить частоту передачи и тем самым компенсировать «последовательность». Это преимущество стало определяющим: большинство современных интерфейсов — последовательные. Сравните: USB-кабель с 4 проводами обеспечивает скорость до 480 Мбит/с (USB 2.0) или даже 5 Гбит/с (USB 3.0).

Более того, существуют методы, которые позволяют встроить информацию о тактовом сигнале прямо в битовый поток. В таком случае для передачи данных достаточно всего одного провода.

Раз уж мы заговорили о синхронизации, давайте поговорим о синхронных и асинхронных интерфейсах.

### Синхронная и асинхронная передача

Мы выяснили, что данные передаются бит за битом. Но как приёмник понимает, в какой момент считывать очередной бит? Существуют два подхода к этой задаче.

**Синхронная передача** использует отдельный тактовый сигнал. Передатчик генерирует последовательность импульсов на специальной линии (обычно называется CLK или SCK), и каждый импульс говорит приёмнику: «сейчас читай». Приёмник считывает состояние линии данных по фронту или спаду тактового сигнала.

![[sync_scheme.png]]


Преимущества такого подхода — простота и надёжность. Приёмнику не нужно угадывать момент считывания, его задаёт передатчик. Это позволяет достигать высоких скоростей передачи. Недостаток — нужен дополнительный провод для тактового сигнала. Примеры синхронных интерфейсов: SPI, I2C.

**Асинхронная передача** обходится без тактового сигнала. Вместо этого передатчик и приёмник заранее договариваются о скорости передачи — количестве бит в секунду. Эту скорость называют **бодовой скоростью** (*англ. baud rate*). Чтобы приёмник понял, где начинается и заканчивается байт, данные обрамляются специальными битами: стартовым в начале и стоповым в конце.

![[async_scheme.png]]

Преимущество — меньше проводов, что удобно при связи между платами. Недостаток — скорость на обоих устройствах должна быть настроена одинаково. Если скорости не совпадают, данные будут приняты с ошибками. Пример асинхронного интерфейса: UART.

>[!NOTE] Из практики
>На Raspberry Pi 4 вы работали с SPI для подключения внешнего АЦП — это синхронный интерфейс, где Pi генерировал тактовый сигнал. Если вы использовали Serial-консоль для отладки — это был UART, асинхронный интерфейс.

Какой подход выбрать? Внутри одной платы, где расстояния короткие, синхронные интерфейсы проще и быстрее. Между платами или на большие расстояния асинхронные интерфейсы удобнее — не нужно тянуть дополнительный провод для такта.

### Симплекс, дуплекс и полудуплекс

Ещё одна характеристика интерфейса — направление передачи данных. Может ли устройство одновременно передавать и принимать, или только по очереди?

**Симплекс** (*англ. simplex*) — передача данных только в одном направлении. Одно устройство всегда передаёт, другое всегда принимает. Пример — пульт дистанционного управления: он отправляет команды телевизору, но ничего не получает обратно.

![[simplex.png]]

**Полудуплекс** (*англ. half-duplex*) — передача данных в обоих направлениях, но не одновременно. Устройства «говорят по очереди», как в рации: пока один передаёт, другой слушает. Пример — I2C: линия данных SDA одна, и в каждый момент времени её использует либо ведущий, либо ведомый.

![[half_duplex.png]]

**Полный дуплекс** (*англ. full-duplex*) — передача данных в обоих направлениях одновременно. Каждое устройство может передавать и принимать в один и тот же момент времени. Для этого нужны отдельные линии для каждого направления. Примеры — SPI (отдельные линии MOSI и MISO) и UART (отдельные линии TX и RX).

![[full_duplex.png]]

На практике полный дуплекс не всегда используется в полной мере. Например, SPI позволяет одновременную передачу в обе стороны, но многие протоколы устройств этим не пользуются — сначала ведущий отправляет команду, затем ведомый отвечает.



| **[[Внешняя периферия микроконтроллера\|Предыдущий раздел]]** | [[Как работать с внешней периферией\|К занятию]] | **[[Интерфейсы внешней периферии\|Следующий раздел]]** |
| ------------------------------------------------------------- | ------------------------------------------------ | ------------------------------------------------------ |
